[["index.html", "Big Data Case Studies Chapter 1 Introduction", " Big Data Case Studies Benjamin Buchwitz 2021-05-15 Chapter 1 Introduction This repo contains course materials. "],["getting-started.html", "Chapter 2 Getting Started 2.1 Sensor Development Environment 2.2 Gateway Development Environment", " Chapter 2 Getting Started 2.1 Sensor Development Environment This Chapter is a short guide for setting up your development environment. Until you receive your hardware you can start with installing the necessary software. 2.1.1 Software Setup Download Segger Embedded Studio for ARM 5.10d (https://www.segger.com/downloads/embedded-studio) Download nRF5_SDK_15.3.0_59ac345.zip (https://developer.nordicsemi.com/nRF5_SDK/nRF5_SDK_v15.x.x/) Clone https://github.com/bchwtz-fhswf/ruuvi.firmware.c. Copy the extracted ZIP from 2. Inside the cloned folder (If you don’t know how to clone a git repository look at https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository. The final result should look like this: Open SEGGER and click File \\(\\rightarrow\\) Open Solution, navigate to the cloned repository and open ruuvi.firmware.c. The project should now be inside SEGGER. Search Project ‘ruuvitag_b’ on the left inside SEGGER, right-click and choose Set as Active Project. 2.1.2 Hardware Setup Open your ruuvi tag, take PCB &amp; battery out (you can do so with a little screwdriver or by gently pulling on the battery clip) Remove the battery by pressing it down Connect the “Tag Connector” cable + plug to your ruuvi tag Connect the other side of the tag connector to the Debug in slot on the Nordic SDK Connect your SDK over USB with your PC To test if everything is right, open SEGGER and click Target \\(\\rightarrow\\) Connect J-Link. SEGGER should connect to your SDK To flash your ruuvi tag with the cloned firmware, click Target \\(\\rightarrow\\) Erase All, afterwards click Build \\(\\rightarrow\\) Build and Run. 2.1.3 Testing the Gateway Connection Connect your Raspberry Pi to a screen via HDMI. Connect your Raspberry to your WiFi. Activate SSH and VNC by clicking on the raspberry on the top left \\(\\rightarrow\\) Preferences \\(\\rightarrow\\) Raspberry-Pi-Configuration \\(\\rightarrow\\) Interfaces, change SSH and VNC to activated. On your PC, download PuTTY (https://www.putty.org/) Get your Raspberry’s IP-Adress by opening a command line on your PC and and type: ping raspberrypi.local Open PuTTY, type the IP-Adress into the Host Name field. You can save it by entering a name into the “Saved Sessions” field and pressing “save”. Afterwards select “open”. When asked for the username type pi and afterwards enter your password. If you did not change it on Raspberry’s startup it should be raspberry. To clone the Gateway repository (https://github.com/bchwtz-fhswf/gateway) onto your pi, you need a SSH Key which is connected to your account. Generate it by following the instructions in https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent for Linux (you dont have to pass it to a key agent) and add it to your account by following the instructions in https://docs.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account Clone the gateway repository to your raspberry by typing the folowing into the remote console window connected to your raspberry. When asked, enter the SSH Key password you initiated while generating the key. git clone git@github.com:bchwtz-fhswf/gateway.git Before you are able to execute some of the scripts, you have to install some Python modules by typing or pasting the following commands. (You can paste into a PuTTY window by right-clicking) pip3 install ruuvitag_sensor pip3 install crcmod pip3 install pygatt pip3 install interruptingcow sudo apt-get install bluez bluez-hcidump To try if your setup is working, navigate to the cloned repo and type python3 GetConfigFromSensor.py. You should see something like this: To properly use the gateway library, type python3 into the remote console window. This activates an interactive python session. import SensorGatewayCommunication test = SensorGatewayCommunication.RuuviTagAccelerometerCommunication() test.activate_logging_at_sensor() # Wait a few seconds and type test.get_last_sample_acceleration_data() # Wait 2 minutes and type abc = test.get_acceleration_data() You should see some x,y and z acceleration data after executing the get_last_sample_acceleration_data function. After get_acceleration_data, you should see a lot of hex data flooding through your screen. They get saved inside a *.csv file for further analysis. CONGRATULATIONS! YOUR SETUP IS READY!!! # TODO: Add Explanation sudo apt-get install libatlas-base-dev sudo apt-get install python3-pandas sudo apt-get install python3-numpy If you are constanly testing gateway-sensor interactions that it may be more convenient to do so via a webbrowser and not via a SSH remote shell. For this you can install a jupyter hub on the Pi https://towardsdatascience.com/setup-your-home-jupyterhub-on-a-raspberry-pi-7ad32e20eed 2.2 Gateway Development Environment "],["sensor.html", "Chapter 3 Sensor 3.1 Initializing acceleration logging 3.2 Retrieving data from FIFO 3.3 Using the data by hearbeat 3.4 Initialization during boot 3.5 Implementation 3.6 Ringbuffer module", " Chapter 3 Sensor The following figure shows the high level architecture of acceleration data logging in Ruuvi Tag. All configuration is done via the gateway. It communicates with the Ruuvi Tag using the Nordic UART interface via GATT messages transported by Bluetooth Low Energy (BLE). Most logic regarding acceleration logging is implemented inside the module app_accelerometer_logging.c. Three use cases are shown in this figure. 3.1 Initializing acceleration logging The initialization is shown with blue arrows and numbers in black circles until #4. To activate acceleration logging the gateway sends the message 0xFA 0xFA 0x0A 0x01. In general GATT messages are handled by the function handle_comms() inside the module app_comm.c. Messages regarding acceleration logging are delegated to the function handle_lis2dh12_comms() inside the same module. After receiving the message to activate acceleration logging the function app_enable_sensor_logging() inside the module app_accelerometer_logging.c in called (1). The first step in activation is to check if some conditions are fulfilled. The function returns an error code if acceleration logging is already active or if it is called on a sensor which does not include an LIS2DH12. This check is done by calling find_sensor() inside of app_sensor.c (2). This function returns the sensor context. The sensor context consists of several information about the sensor. The next step associates the function on_fifo_full() from app_accelerometer_logging.c with the interrupt pin retrieved from the sensor context (3). The last step is to activate FIFO and interrupt generation inside the LIS2DH12. This is done by calling two functions from the sensor context. At last the function pointer to data_get() inside the sensor context is replaced by the pointer to the function lis2dh12_logged_data_get(). 3.2 Retrieving data from FIFO When FIFO is full inside LIS2DH12 the interrupt starts the function on_fifo_full(). This function does not directly handle the new data. It schedules a call to fifo_full_handler(). Instead of on_fifo_full() this is called in the main thread of the application. If processing is done inside a function inside an interrupt context this prevents processing of another interrupt. This should be avoided. Inside fifo_full_handler() the FIFO from LIS2DH12 is read (5). The values are store in memory in raw format to be ready to present them to the function lis2dh12_logged_data_get() which is important for heartbeat. In parallel the raw values are compacted by removing all unused bits. This is done by the functions pack8/10/12(). A timestamp is added to the compacted values. These values are handover to the ringbuffer which writes them to flash (6). 3.3 Using the data by hearbeat This use case is shown with magenta arrows and numbers inside magenta circles in the figure above. The heartbeat retrieves the values from all sensors by calling the function app_sensor_get() inside the module app_sensors.c. In the original setup this function calls ri_lis2dh12_data_get() inside ruuvi_interface_lis2dh12.c. During initialization this function is replaced by lis2dh12_logged_data_get(). lis2dh12_logged_data_get() retrieves the raw acceleration values from memory. Then the values are parsed by calling ri_lis2dh12_raw_data_parse() and returned to the heartbeat. 3.4 Initialization during boot All sensor initialization is done inside setup() from main.c. This function calls app_acc_logging_init() inside app_accelerometer_logging.c. The function checks if the ringbuffer exists. If this is true it activates acceleration logging as described earlier. 3.5 Implementation 3.5.1 app_accelerometer_logging.c 3.5.1.1 rd_status_t app_enable_sensor_logging(void) Enables the logging of acceleration data. Special error codes RD_ERROR_INVALID_STATE If logging is already enabled. RD_ERROR_NOT_FOUND If LIS2DH12 is not available. 3.5.1.2 rd_status_t app_disable_sensor_logging(void) Disables the logging of acceleration data. Special error codes RD_ERROR_INVALID_STATE If logging is already disabled. RD_ERROR_NOT_FOUND If LIS2DH12 is not available. 3.5.1.3 void on_fifo_full (const ri_gpio_evt_t evt) Callback function when FIFO full interrupt occurs at LIS2DH12. This functions schedules the execution of void fifo_full_handler (void * p_event_data, uint16_t event_size). See ruuvi_interface_scheduler.h for parameters used in this function. 3.5.1.4 void fifo_full_handler (void * p_event_data, uint16_t event_size) This function reads the FIFO and stores the data inside the ringbuffer. See ruuvi_interface_scheduler.h for parameters used in this function. 3.5.1.5 void pack8/10/12(const uint16_t sizeData, const uint8_t* const data, uint8_t* const packeddata) These functions remove unused bits from the raw accelerometer values in 8/10/12 bit format and store them in compact form. Parameters sizeData in Size of input data. data in Input data. packeddata in/out Memory for storing compacted data. 3.5.1.6 rd_status_t lis2dh12_logged_data_get (rd_sensor_data_t * const data) This function retrieves raw accelerometer values from memory. The values are parsed and returned inside data. It is called by app_sensor_get() inside app_sensor.c if accelerometer logging is active. Parameters raw_data in/out Memory for storing accelerometer values. 3.5.1.7 rd_status_t app_acc_logging_send_last_sample(const ri_comm_xfer_fp_t reply_fp) This function is called when a request to send the last sample is received by GATT/UART. It retrieves the last sample from memory, does the compacting of the bits by calling pack8/10/12() and sends the data to the requester. Parameters reply_fp in Function pointer to reply function. Special error codes RD_ERROR_INVALID_STATE If logging is not active. 3.5.1.8 rd_status_t app_acc_logging_state(void) This function is used to query the state of accelerometer logging. It is called when a control message is received by GATT/UART to return this state to the caller. Special error codes RD_SUCCESS If logging is active. RD_ERROR_INVALID_STATE If logging is not active. 3.5.1.9 rd_status_t app_acc_logging_configuration_set (rt_sensor_ctx_t* sensor, rd_sensor_configuration_t* new_config) This function is called when a request to update the sensor configuration is received by GATT/UART. It checks every configuration parameter if it should be changed. It also checks if the value is different than actual value. If a change is detected it clears the ringbuffer, updates the configuration and stores the configuration in flash. Parameters sensor in Sensor context of the sensor which configuration should be changed. new_config in Structure containing the new configuration values. 3.5.1.10 rd_status_t app_acc_logging_init(void) Initialize acceleration logging during boot. If logging was active before reboot it will be activated. If logging was not active before reboot this function return RD_SUCCESS without activating acceleration logging. The state if logging was active before reboot is detected by looking for the ringbuffer. If the ringbuffer exists, the logging must be active before reboot. This function is called from setup(). 3.5.1.11 rd_status_t app_acc_logging_uninit(void) The uninitialization of acceleration logging disables the logging if it is actually active. If logging is not active this function return RD_SUCCESS without doing anything. 3.5.2 app_comms.c 3.5.2.1 void handle_comms (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) Added new switch/case which forwards messages regarding configuration and control of acceleration logging to the function handle_lis2dh12_comms(). 3.5.2.2 rd_status_t handle_lis2dh12_comms (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) This function handles the GATT/UART communication needed to control the functionality of acceleration logging. Parameters reply_fp in Function pointer to reply function. raw_message in Message received. data_len in Length of the received message. 3.5.3 app_config.h Added macro APP_SENSOR_LOGGING to control compilation of app_accelerometer_logging.* If APP_SENSOR_LOGGING is not defined or is defined as 0 the functionality of logging of acceleration data is not available in the application. 3.5.4 app_heartbeat.c 3.5.4.1 void heartbeat (void * p_event, uint16_t event_size) If acceleration logging is activated, than logging of environmental data is disabled to avoid extreme fragmentation of flash memory. 3.5.5 app_sensor.c 3.5.5.1 rt_sensor_ctx_t* app_sensor_find (const char *name) Find sensor by its name. Works only with initialized sensors, will not return a sensor which is supported in firmware but not initialized. This function is called by app_enable_sensor_logging() and app_disable_sensor_logging() to retrieve the sensor context. Parameters name in Name of the sensor. 3.5.6 main.c 3.5.6.1 void setup (void) Added call to app_acc_logging_init() to initialize acceleration logging. 3.5.7 ruuvi_interface_lis2dh12.c 3.5.7.1 rd_status_t ri_lis2dh12_acceleration_raw_get (uint8_t * const raw_data) This function reads raw acceleration values from the registers of LIS2DH12. It is called from the interrupt handler inside app_accelerometer_logging.c and from ri_lis2dh12_data_get(). Parameters raw_data in/out Memory for storing raw accelerometer values. 3.5.7.2 rd_status_t ri_lis2dh12_data_get (rd_sensor_data_t * const data) The original function ri_lis2dh12_data_get() is split into retrieving raw values from the sensor and parsing these data. Parsing is done by ri_lis2dh12_raw_data_parse(). This function is used if the acceleration logging is not active. If acceleration logging is active this function is replaced by lis2dh12_logged_data_get(). Parameters data in/out Structure for storing parsed accelerometer values. 3.5.7.3 rd_status_t ri_lis2dh12_raw_data_parse (rd_sensor_data_t * const data, axis3bit16_t *raw_acceleration, uint8_t *raw_temperature) This function parses raw values from the sensor and stores the values inside data. It is called from ri_lis2dh12_data_get() and from lis2dh12_logged_data_get(). Parameters data in/out Structure for storing parsed accelerometer values. raw_acceleration in Raw acceleration values. raw_temperature in Raw temperature value. If used from lis2dh12_logged_data_get() this parameter is NULL. 3.5.8 ruuvi_nrf5_sdk_rtc_mcu.c 3.5.8.1 rd_status_t ri_set_rtc_millis(uint64_t millis) Set system time by external source. Set RTC to zero. Parameters millis in External time. 3.6 Ringbuffer module ruuvi.firmware.c\\src\\ruuvi.drivers.c\\src\\tasks\\ruuvi_task_flash_ringbuffer.h ruuvi.firmware.c\\src\\ruuvi.drivers.c\\src\\tasks\\ruuvi_task_flash_ringbuffer.c 3.6.1 General functionality A ringbuffer is a data structure that represents a fixed-sized queue. As the following figure shows, the current read or write position is indicated by the two attributes start and end. After every read or write, the corresponding value points to the next area. 3.6.2 Project-related use case In the use case of the Ruuvi Tag the data of the ringbuffer should be stored in the flash memory of the sensor. This flash memory is structured in flashpages, each consisting of several records. The implemented ringbuffer reserves a selected number of flashpages and stores its current state (size, start and end attribute, reserved pages) in the following struct at a previously defined memory address. The maximum size of the ringbuffer is defined by the property RT_FLASH_RINGBUFFER_MAXSIZE. For the memory access the FDS library is used. rt_flash_ringbuffer_state_t size uint8_t Number of pages start uint8_t Start position end uint8_t End position reserved_pages[] fds_reserve_token_t Array of fds_reserve_token The following struct makes it possible to buffer the accumulating accelerometer data until the amount of data for an entire flashpage is reached. rt_flash_ringbuffer_flashpage_t max_size uint16_t Maximum size of the flashpage actual_size uint16_t Actual size of the flashpage packeddata[4073] uint8_t Actual picked data 3.6.3 Implemented functions 3.6.3.1 rd_status_t rt_flash_ringbuffer_create(const uint32_t page_id, const uint32_t record_id, const uint8_t number_of_pages, const uint16_t page_size) This function creates a new ringbuffer, reserves the pages in flash and initializes the ringbuffer state. Parameters page_id in PageID of the ringbuffer state record_id in RecordID of the ringbuffer state number_of_pages in Number of pages in the ringbuffer page_size in Size of each page in the ringbuffer 3.6.3.2 rd_status_t rt_flash_ringbuffer_create(const uint32_t page_id, const uint32_t record_id, const uint16_t size, const uint8_t* packeddata, rt_flash_ringbuffer_flashpage_t* flashpage) This function collects data to store in ringbuffer. After the amount of data of an entire flashpage is reached, the write operation is called. Parameters page_id in PageID of the ringbuffer state record_id in RecordID of the ringbuffer state size in Size of packeddata packeddata in Data to collect for flashpage flashpage in/out Flashpage struct 3.6.3.3 rd_status_t rt_flash_ringbuffer_write(const uint32_t page_id, const uint32_t record_id, const uint16_t size, const void* data) This function writes data to the ringbuffer. Parameters page_id in PageID of the ringbuffer state record_id in RecordID of the ringbuffer state size in Size of data data in Data to be written 3.6.3.4 rd_status_t rt_flash_ringbuffer_read(const uint32_t page_id, const uint32_t record_id, const uint16_t size, void* data) This functiion reads data from the ringbuffer. Parameters page_id in PageID of the ringbuffer state record_id in RecordID of the ringbuffer state size in Size of data data in/out Data to be read 3.6.3.5 rd_status_t rt_flash_ringbuffer_clear(const uint32_t page_id, const uint32_t record_id) This function clears the contents of the ringbuffer (start/end attribute of the ringbuffer state are set to 0). Parameters page_id in PageID of the ringbuffer state record_id in RecordID of the ringbuffer state 3.6.3.6 rd_status_t rt_flash_ringbuffer_delete(const uint32_t page_id, const uint32_t record_id) This function deletes the entire ringbuffer. Parameters page_id in PageID of the ringbuffer state record_id in RecordID of the ringbuffer state 3.6.4 Exemplary use #include &quot;ruuvi_task_flash_ringbuffer.h&quot; // create ringbuffer rd_status_t error = rt_flash_ringbuffer_create(FILE_ID, RECORD_KEY, RT_FLASH_RINGBUFFER_MAXSIZE, 4073); // create flashpage struct rt_flash_ringbuffer_flashpage_t flashpage; flashpage.actual_size = 0; flashpage.max_size = 4073; // write data int i=1; while(i &lt;= 1500) { rt_flash_ringbuffer_collect_flashpage(FILE_ID, RECORD_KEY, sizeof(i), &amp;i, &amp;flashpage); // the collect operation calls the write operation when the data size for a flashpage is reached i++; } // read data from flash rt_flash_ringbuffer_flashpage_t flashpage_read; error = rt_flash_ringbuffer_read(FILE_ID, RECORD_KEY, sizeof(flashpage_read), &amp;flashpage_read); "],["gateway.html", "Chapter 4 Gateway 4.1 Sensor Gateway Communication Library 4.2 Advertisement logging 4.3 Data storage format", " Chapter 4 Gateway The gateway has three different tasks: Manipulate the state of one or more sensors via control messages Receive acceleration data from one or more sensors, parse and store them Logging Bluetooth advertisements from sensors For the first two tasks there is the “Sensor Gateway Communication” library. An executable is used to log the advertisements. Both are written in python. To run the code, you need a few libraries which are listed below: ruuvitag_sensor bluez crcmod pygatt interruptingcow 4.1 Sensor Gateway Communication Library This library is used for communication between the gateway and the sensors. It sends messages to the sensor to change their state or get their data. The library has the following functions. 4.1.1 Activate acceleration logging The “activate_logging_at_sensor()” function activates logging at all sensors in Bluetooth range of the gateway. It can also be used with a mac address as argument to activate the logging at a specific sensor. To activate the logging, the gateway sends a control acceleration logging (6.1.7) message to the target sensor. The message content is F0A 0xFA 0x0A 0x01. If Logging is already activated an error message (6.2.1) will be received. 4.1.2 Deactivate acceleration logging The “deactivate_logging_at_sensor()” function deactivates logging at all sensors in Bluetooth range. With a mac address as argument, a specific sensor can be deactivated. To deactivate the logging, the gateway sends a control acceleration logging (6.1.7) message to the target sensor. The message content is 0xFA 0xFA 0x0A 0x00. Stopping the logging cause a deletion of all flash pages. If Logging is not activated an error message (6.2.1) will be received. 4.1.3 Set sensor configuration With the “set_config_sensor()” function three sensor properties can be manipulated: Sampling rate (sampling_rate): Measuring interval of the sensor. Allowed values can be found in Chapter (6.1.3). Sampling resolution (sampling_resolution): Resolution of the measured values. Allowed values can be found in Chapter (6.1.3). Measuring range(measuring_range): Measuring range. Allowed values can be found in Chapter (6.1.3). The configuration will be sent via a “Set configuration of acceleration sensor” (6.1.3) message to all sensors in Bluetooth range, if no specific mac address is passed as argument. Only arguments with allowed values will be set. All others stay as they are. After setting the configuration all flash pages will be deleted. This can cause a loss of data. The Sensor send a status response message (6.2.1) to the gateway if the configuration was set successful or not. 4.1.4 Set sensor time With the “set_sensor_time() “ function all sensors in Bluetooth range will be set to the current time in UTC. Giving a specific mac address as argument will set the time at this sensor only. To set the sensor time a “Set system time” (6.1.5) message, with the current time, will be send. After setting the sensor time all flash pages will be deleted. This can cause a loss of data. The Sensor send a response message (6.2.1) to the gateway if the time was set successful or not. 4.1.5 Get sensor configuratin The “get_config_from_sensor()”send a “Read configuration of acceleration sensor” (6.1.4) message to the target sensor. The sensor returns with a “Configuration response” (6.2.3) message. The configuration will be displayed. If no argument is given all sensors in Bluetooth range will be messaged. To see a specific sensor configuration, use its mac address as argument. 4.1.6 Get sensor time The “get_time_from_sensor()” function returns the current time from all sensors in Bluetooth range. To see a specific sensor time, use its mac address as argument. The function sends a “Read system time” (6.1.6) message to all targets and receives “Timestamp response” (6.2.4) messages. 4.1.7 Get last sample The “get_last_sample_acceleration_data()” collects, parse and displays the last 32 samples from all sensors in Bluetooth range. To do this, the gateway send a “Start transmitting last sample” (6.1.1) Message to the targets and receives the data which are followed by an “End of data message” (6.2.2). The displayed values are shown as X-, Y-, Z-Values. Use the mac address to see samples from a specific Sensor. 4.1.8 Get acceleration data The “get_acceleration_data()” collect all samples from all sensors in Bluetooth range, parse and stores them in a Csv file. To do this, the gateway sends a “Start transmitting logged data” (6.1.2) Message to all targets and receives the data which are followed by an “End of data message” (6.2.2). 4.1.9 Find Macs The “find_tags_mac()” returns all unique mac addresses that are found. 4.2 Advertisement logging This executable is used for logging all advertisements that are send from any sensor in the Bluetooth rang. It parses the messages the gateway receives in a human readable design and stores it in a Csv file. The “decode_data()” function from the ruuvitag_sensor library is used to parse the received messages from the sensors. 4.3 Data storage format For an easy access, the received data is stored in csv files. Separate Files are used for the acceleration logging and the advertisement logging. They both have different structures which are shown in this chapter. 4.3.1 Csv file acceleration Logging Five values will be stored in these Csv files. These values are: • Acceleration in X directory • Acceleration in Y directory • Acceleration in Z directory • Timestamp • Mac address The name of the Csv file will be “acceleration” plus the observation time. 4.3.2 Csv file advertisement Logging Fourteen values will be stored in these Csv files. These values are: • Data format • Humidity • Temperature in °C • Pressure in Pa • Acceleration • Acceleration in X directory • Acceleration in Y directory • Acceleration in Z directory • Tx power in dBm • Battery in mV • Movement counter • Measurement sequence • Mac address • Timestamp The name of the Csv file is the date of the observation. One Csv file will only include observations from one day. "],["backend.html", "Chapter 5 Backend", " Chapter 5 Backend Lorem ipsum "],["ble-gatt-messages.html", "Chapter 6 BLE GATT Messages 6.1 Control messages 6.2 Response messages 6.3 Data message 6.4 Communication example", " Chapter 6 BLE GATT Messages Communication between Gateway and Sensor is done via Bluetooth Low Energy. It uses the Nordic UART service which itself uses the Bluetooth GATT protocol. Three types of messages are used. The Gateway sends control messages to the sensor to set or read configuration or start transmission of logged data. The Sensor responds to control messages via response messages. This message type transports status information or configuration data. If the Gateway requests the Sensor to send logged data, this data is sent by data messages. To transport all data many data messages are used in sequence. The end of data is signaled by a response message. The messages are differentiated by the first byte. 6.1 Control messages Control messages are indicated by the value 0xFA in the first position. This byte is repeated in the second position. The type of the message is distinguished by the third byte. The general structure of a control message is show in the following table. Header Header Type Parameter 0xFA 0xFA XX Zero or more Parameter Control messages must be padded by nullbytes to a minimum length of 11 bytes. This requirement is introduced by the Ruuvi firmware. The padding bytes are not shown in the following description of the messages. 6.1.1 Start transmitting last sample (0x03) This message starts transmitting the last sample of acceleration data. This sample consists of 32 tuples of (X,Y,Z) values. It is taken from RAM and transmitted to the gateway by using data messages. The transmission of the data is followed by a end of data message which signals the end of the data. This message takes no parameters. It’s concrete content is: 0xFA 0xFA 0x03. If acceleration logging is not active, the Sensor responds a status response containing error code RD_ERROR_INVALID_STATE. 6.1.2 Start transmitting logged data (0x05) This message starts transmitting the logged acceleration data from the ringbuffer. The data includes the last page which is not complete full and is not yet written to flash. The transmission of the data is followed by a end of data message which signals the end of the data. After downloading the logged data, the ringbuffer is empty. This message takes no parameters. Its concrete content is: 0xFA 0xFA 0x05. If acceleration logging is not active, the Sensor responds with a status response containing error code RD_ERROR_INVALID_STATE. 6.1.3 Set configuration of acceleration sensor (0x06) This message is used to set the configuration of the acceleration sensor (LIS2DH12). The message takes 8 Parameters. The Sensor responds to this message with a status response. The parameters are as follows. Parameter Description P1 Rate of sampling in smaples per second. Allowed values are 1Hz, 10Hz, 25Hz, 50Hz, 100Hz, 200Hz, 400Hz. P2 Resolution in bits. Allowed values are 8, 10, 12. P3 Measuring range. Allowed values are 2G, 4G, 8G, 16G. P4 DSP function. See datasheet of LIS2DH12. P5 DSP parameter. See datasheet of LIS2DH12. P6 Mode of operation. Allowed values are 0xF2, 0xF3, 0xF4. See ruuvi_driver_sensor.h for explanation. P7 Reserved. Set to 0x00. P8 Reserved. Set to 0x00. All values from P1 to P6 can be set to 0xFF which means ‘do not change this values’. The concrete content of this message is 0xFA 0xFA 0x06 P1 P2 P3 P4 P5 P6 P7 P8. 6.1.4 Read configuration of acceleration sensor (0x07) This message is used to read the configuration of the acceleration sensor (LIS2DH12). The message takes no parameters. The Sensor responds to this message by a response message which transmits the configuration. The concrete content of this message is: 0xFA 0xFA 0x07. 6.1.5 Set system time (0x08) This message is used to set the RTC of the sensor to a timestamp which is part of the message. The time is expressed in milliseconds. It must be transmitted in little-endian byte sequence. The sensor responds to this message with a status response. The concrete content of this message is 0xFA 0xFA 0x08 XX XX XX XX XX XX XX XX. 6.1.6 Read system time (0x09) This message is used to read the RTC of the sensor. The sensor responds to this message with a timestamp response. The concrete content of this message is 0xFA 0xFA 0x09. 6.1.7 Control acceleration logging (0x0A) This message is used to activate or deactivate acceleration logging. It takes one parameter. The parameter is interpreted as a boolean value. If it maps to true, acceleration logging is activated. If it maps to false, acceleration logging is deactivated. The sensor responds to this message using a status response. Activating acceleration logging when it is already active results in an error. Deactivating acceleration logging when it is not active results in an error. The concrete content of this message is 0xFA 0xFA 0x0A XX. Where XX can be 0x00 or 0x01. 6.1.8 Query status of acceleration logging (0x0B) This message is used to query the status of acceleration logging. The sensor responds to this message with a status response. If logging is active, the response contains the status RD_SUCCESS if logging is not active the status is RD_ERROR_NOT_INITIALIZED. The concrete content of this message is 0xFA 0xFA 0x0B. 6.2 Response messages Response messages are indicated by the value 0xFB as the first byte. The type of the message is differentiated by the second byte. The general structure of a response message is show in the following table. Header Type status Parameter 0xFB XX status Zero or more Parameter Every response message returns a status code as the result of the processing as the third byte. It must be interpreted as a bitfield. The bits represent the different error conditions. The following table show the error conditions. In case of mulpilte arrors more than one bit can be set. If no bit is set the processing was successful. Value Error status==0 RD_SUCCESS: No error 1 RD_ERROR_INTERNAL: Internal Error 2 RD_ERROR_NO_MEM: No Memory for operation 4 RD_ERROR_NOT_FOUND: Not found 8 RD_ERROR_NOT_SUPPORTED: Not supported 16 RD_ERROR_INVALID_PARAM: Invalid Parameter 32 RD_ERROR_INVALID_status: Invalid status, operation disallowed in this status 64 RD_ERROR_INVALID_LENGTH: Invalid Length 128 RD_ERROR_INVALID_FLAGS: Invalid Flags 256 RD_ERROR_INVALID_DATA: Invalid Data 512 RD_ERROR_DATA_SIZE: Invalid Data size 1024 RD_ERROR_TIMEOUT: Operation timed out 2048 RD_ERROR_NULL: Null Pointer 4096 RD_ERROR_FORBIDDEN: Forbidden Operation 8192 RD_ERROR_INVALID_ADDR: Bad Memory Address 16384 RD_ERROR_BUSY: Flash Busy 32768 RD_ERROR_RESOURCES: Not enough resources for operation 65535 RD_ERROR_NOT_IMPLEMENTED: Not implemented yet 131072 RD_ERROR_SELFTEST: Self-test fail 262144 RD_STATUS_MORE_AVAILABLE: Driver has more data queued 524288 RD_ERROR_NOT_INITIALIZED: Driver is not initialized. 1048576 RD_ERROR_NOT_ACKNOWLEDGED: Ack was expected but not received 2097152 RD_ERROR_NOT_ENABLED: Driver is not enabled 6.2.1 Status response (0x00) This message is used to return a status code to the gateway if no other information is available. The concrete content of this message is 0xFB 0x00 SS. Where SS is the status code. 6.2.2 End of data message (0x03, 0x05) This message is sent to the gateway after returning data. It signals the end of the transmission. The type byte (0x03, 0x05) maps to the type of data requested. This message contains nine parameters. The current configuration of the acceleration sensor are the first eight parameter. The structure is the same as shown in the set configuration message. The CRC16 value of the transmitted data is the 9th parameter. To compute the CRC16 value the polynom 0x11021 with the initial value 0xFFFF is used. The output bytes are not reversed and not XOR’d. The CRC value is of size 2 bytes. It is transfered in little-endian byte sequence. The concrete content of this message is 0xFB 0x03/0x05 SS P1 P2 P3 P4 P5 P6 P7 P8 CRC1 CRC2. Where SS is the status code. 6.2.3 Configuration response (0x07) This message is sent to the gateway after requesting the current configuration. The message contains eight parameters containing the current configuration. If the status code signals an error the transmitted values is undefined. The concrete content of this message is 0xFB 0x07 SS P1 P2 P3 P4 P5 P6 P7 P8. The values P1 to P8 map to the same values as shown in set configuration message. Where SS is the status code. 6.2.4 Timestamp response (0x09) This message is sent to the gateway after requesting the system time. The message contains one parameter. The parameter is a 8 byte value containing the current timestamp. The bytes are transferred in little-endian sequence. If the status code signals an error the transmitted value is undefined. The concrete content of this message is 0xFB 0x09 SS XX XX XX XX XX XX XX XX. Where SS is the status code. 6.3 Data message Data messages are used to transfer logged acceleration data. A data message starts with the byte 0xFC. After the start byte there follows up to 19 bytes of data. The concrete content of this message is 0xFC XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX. The data is returned in blocks of 32 tuples of x-, y-, z-values. Every block is preceded by the timestamp when the interrupt occured which this block generates. To decode the data block the information about the resolution and the scale is needed. This information is transmitted by the end of data message. All values are transferred in little-endian byte sequence. After de-compacting every value must be interpreted as the most significant part of an 16 bit wide signed integer. To get the real acceleration value from this intermediate value multiply it by one of the following factors. Scale / Resolution 8 bit 10 bit 12 bit 2G \\(\\frac{16}{256*1000}\\) \\(\\frac{4}{64*1000}\\) \\(\\frac{1}{16*1000}\\) 4G \\(\\frac{32}{256*1000}\\) \\(\\frac{8}{64*1000}\\) \\(\\frac{2}{16*1000}\\) 8G \\(\\frac{64}{256*1000}\\) \\(\\frac{16}{64*1000}\\) \\(\\frac{4}{16*1000}\\) 16G \\(\\frac{192}{256*1000}\\) \\(\\frac{48}{64*1000}\\) \\(\\frac{12}{16*1000}\\) 6.3.1 12 bit data format In 12 bit resolution mode two values are transmitted inside 3 bytes. See following figure. 6.3.2 10 bit data format In 10 bit resolution mode four values are transmitted inside 5 bytes. See following figure. 6.3.3 8 bit data format In 8 bit resolution mode every value is transmitted seperatly. See following figure. 6.4 Communication example The following figure shows an example communication. "],["sensor-1.html", "Chapter 7 Sensor 7.1 Hardware 7.2 Software", " Chapter 7 Sensor 7.1 Hardware 7.1.1 External Flash Memory For more extensive data logging external memory (not in the SoC) is required. The most promising candidate is the Macronix MX25R as it supports low power battery driven applications, is quite flexible in terms of required voltage and is also used in some newer Nordic reference designs. 7.1.2 Board Redesign The current sensor board revision features two antennas, while the bluetooth antenna is required and onboard NFC antenna is not used, therefore the board footprint could be smaller. Inspiration for a board revision could be drawn from the discontinued nRF51822 Bluetooth Smart Beacon Kit reference design. 7.2 Software 7.2.1 Implementation ID’s used in GATT messages and for storing the ringbuffer state structure are temporary used. These ID’s must be defined/approved by Ruuvi. 7.2.2 General ToDo Remotely customizing the Heartbeat interval (persistence required) Flexibilizing the Logging Rate so that it can be precisely controlled and the sensor supports rates that the accelerometer does not support natively (e.g. 2 Hz) Adapted Advertisement Message Format: Indicate amount of used internal storage to be used by the gateway to trigger connections and manage dowloading of logged data. 7.2.3 Security Questions: * Can Advertisements be encrypted? * How to manage access for downloading internally stored data and allow for encrypted transportation? "],["gateway-1.html", "Chapter 8 Gateway 8.1 Hardware 8.2 Software", " Chapter 8 Gateway 8.1 Hardware 8.1.1 Uninterruptible Power Supply For operating in remote environments the gateway should be equipped with a Uninterruptible Power Supply (UPS). This allows tolerating short power outages and should be configurable to user alternative energy sources such as solar panel or wind turbines to allow for autonomous operation. The most promising products are: * PiJuice Hat * Sixfab UPS Power Hat * UPS PIco HV4.0B Advanced Questions: * How to work with unregulated power sources such as cheap/raw solar panels? * Which UPS provides the best software (Free/Open/Functionality/Reliability)? 8.1.2 Camera A camera is required to record a video stream that is used to derive the ground truth for classification tasks. Use cases can be extended to perform analytics based on the captured images or the video stream. 8.1.2.1 RPi Camera The main camera for the gateway will be the original camera module offered by the Raspberry Pi Foundation, which provides the benefit of an actively maintained software interface and guaranteed compatibility with the used Single Board Computer (SBC). Additionally it is available in two versions, a normal and a NoIR (Night Vision) Version. Questions: * How to match the video feed with the data that is received via Bluetooth? * Which illumination is required for the NoIR Version? * Is it possible to mechanically align the angles (perfect Video overlay) and use both camera versions simultaneously? 8.1.2.2 Thermal Camera For some use cases it may be reasonable to monitor temperatures via a thermal camera. The thermal camera should be seen as an optional addition to the gateway. Questions: * Which module should be chosen in terms of features (especially resolution and connection) and size? * How to align images from all installed cameras (perfectly aligned video stream)? 8.1.3 3g/4g/5g Module Autonomous operation requires a network connection for control and (at least partial) data transfer. Questions: * Which module can be used solely via the GPIO Header (no USB Cable)? * Which module offers the best software interaface( Free/Open/Functionality/Reliability)? 8.1.4 Bluetooth Hardware Alternating and/or extending the Bluetooth Hardware serves two purposes. Having multiple bluetooth devices should allow for monitoring more sensors simultaneously. Including at least one device with support for external antennas would also allow for increased range. Achieving this goal could can be done using at least one (but potentially both) of the following measures: Adding external Bluetooth Hardware Changing the Single Board Computer (SBC) 8.1.5 Case Heat Sink / Active Ventilation 8.2 Software Scheduling and parallelizing download of logged Data "],["backend-1.html", "Chapter 9 Backend", " Chapter 9 Backend Lorem ipsum "],["contributors.html", "Contributors WS 2020 / 2021 SS 2021", " Contributors List of Contributors WS 2020 / 2021 AS FH TH VB SS 2021 "],["commerical-applications.html", "Commerical Applications Literature", " Commerical Applications Examples: Smart Pet Tag: https://shop.gethuan.com/ https://www.nordicsemi.com/News/2020/05/Huan-Tag-pet-wearable-helps-owners-keep-track-of-pets-via-crowd-location-system https://www.nordicsemi.com/News/2019/12/The-PitPat-tracker-monitors-pet-exercise-data-with-Nordic-s-nRF52810 https://digitanimal.com/ayuda/ https://www.beaconzone.co.uk/blog/monitoring-cows-and-sheep-using-beacons/ https://anicare.fi/test/#story https://www.nordicsemi.com/News/2019/04/Cellular-IoT-ear-tag-Healtag-tracks-health-and-location-of-herding-animals https://www.arm.com/why-arm/innovation/arm-designs/herddogg https://herddogg.com/product/tracetag-starter-kit/ https://www.irnas.eu/opencollar-pangolin-tracker/ https://reelyactive.github.io/forward-sensor-data-to-initial-state.html https://shop.reelyactive.com/collections/all/products/showcase-kit https://www.rigado.com/presto-kit/ https://www.rigado.com/cascade-iot-gateway/ https://www.rigado.com/integrated-sensors-and-devices/ https://www.beaconzone.co.uk/blog/understanding-sensor-beacon-accelerometer-data/ https://www.hidglobal.de/products/rfid-tags/identification-technologies/ble-beacons-gateways https://www.mokosmart.com/de/beacon-gateway/ https://www.shopnfc.com/de/71-ble-rtls https://mongoose-os.com/kiwi/ https://www.ingics.com/ble_wifi_gw.html https://docs.openmqttgateway.com/use/ble.html#setting-the-number-of-scans-between-before-connect-attempt Gateways: https://www.beaconzone.co.uk/Gateways Solar asset tracker: https://www.nordicsemi.com/News/2020/11/SODAQ-cellular-IoT-asset-tracker https://www.microtronics.com/de/produkte/ATEX-GSM-Bluetooth-Gateway.html Mainflux: https://ieeexplore.ieee.org/document/8476881 https://www.iotone.com/files/pdf/vendor/MFX-1%20Gateway%20Mainflux.pdf file:///Users/benjamin/Downloads/futureinternet-10-00105-v2.pdf Literature https://www.edgexfoundry.org/get-started/ https://github.com/Klika-Tech/nordic-aws-iot-demo#connect-device https://industrie-wegweiser.de/bluetooth-low-energy-iiot-projektbeispiel/ https://subscription.packtpub.com/book/hardware_and_creative/9781786461087/7/ch07lvl1sec35/implementing-a-bluetooth-gateway-on-the-raspberry-pi https://www.amazon.de/Hands-Industrial-Internet-Things-infrastructure/dp/1789537223/ref=pd_rhf_se_s_sspa_dk_rhf_search_pt_sub_0_7/262-4436963-1836263?_encoding=UTF8&amp;pd_rd_i=1789537223&amp;pd_rd_r=b2eab45b-279b-4b71-99ab-13bd8409b631&amp;pd_rd_w=1wQPj&amp;pd_rd_wg=er1Jl&amp;pf_rd_p=94ba13e0-bc65-4c11-8b62-a4039a72ac24&amp;pf_rd_r=EXNB4ANYJZHV09QBQB7A&amp;psc=1&amp;refRID=EXNB4ANYJZHV09QBQB7A&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyS002SFhCQUVHOFJPJmVuY3J5cHRlZElkPUEwNDExNzY1RkJFNkVVSFEwTEIxJmVuY3J5cHRlZEFkSWQ9QTAyNzQ0MTMzTVkzSUtDRjBQQUNEJndpZGdldE5hbWU9c3BfcmhmX3NlYXJjaF9wZXJzb25hbGl6ZWQmYWN0aW9uPWNsaWNrUmVkaXJlY3QmZG9Ob3RMb2dDbGljaz10cnVl "],["system-info.html", "System Info", " System Info Sys.time() ## [1] &quot;2021-05-15 07:59:51 UTC&quot; sessionInfo() ## R version 4.0.5 (2021-03-31) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.7 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] kableExtra_1.3.4 knitr_1.33 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.6 rstudioapi_0.13 xml2_1.3.2 magrittr_2.0.1 ## [5] rvest_1.0.0 munsell_0.5.0 lattice_0.20-41 colorspace_2.0-1 ## [9] viridisLite_0.4.0 R6_2.5.0 rlang_0.4.11 stringr_1.4.0 ## [13] httr_1.4.2 tools_4.0.5 grid_4.0.5 webshot_0.5.2 ## [17] xfun_0.23 png_0.1-7 htmltools_0.5.1.1 systemfonts_1.0.2 ## [21] yaml_2.2.1 digest_0.6.27 lifecycle_1.0.0 bookdown_0.22 ## [25] Matrix_1.3-2 glue_1.4.2 evaluate_0.14 rmarkdown_2.8 ## [29] stringi_1.6.1 compiler_4.0.5 scales_1.1.1 jsonlite_1.7.2 ## [33] reticulate_1.20 svglite_2.0.0 "]]
