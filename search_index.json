[["index.html", "Big Data Case Studies Chapter 1 Introduction", " Big Data Case Studies Benjamin Buchwitz 2021-02-11 Chapter 1 Introduction This repo contains course materials. "],["getting-started.html", "Chapter 2 Getting Started 2.1 Sensor Dev Env 2.2 Gateway Dev Env", " Chapter 2 Getting Started Wow content Move on 2.1 Sensor Dev Env Content 2.2 Gateway Dev Env test test2 test3 "],["sensor.html", "Chapter 3 Sensor 3.1 Initilizing acceleration logging 3.2 Retrieving data from FIFO 3.3 Using the data by hearbeat 3.4 Initialization during boot 3.5 Implementation", " Chapter 3 Sensor The following figure shows the high level architecture of acceleration data logging in Ruuvi Tag. All configuration is done via the gateway. It communicates with the Ruuvi Tag using the Nordic UART interface via GATT messages transported by Blutooth Low Energy (BLE). Most logic regarding acceleration logging is implemented inside the module app_accelerometer_logging.c. Three usecases are shown in this figure. 3.1 Initilizing acceleration logging The initialization is shown with blue arrows and numbers in black circles until #4. To activate acceleration logging the gateway sends the message 0xFA 0xFA 0x0A 0x01. In general GATT messages are handled by the function handle_comms() inside the module app_comm.c. Message regarding acceleration logging are handled by the function handle_lis2dh12_comms() inside the same module. After receiving the message to activate acceleration logging the function app_enable_sensor_logging() inside the module app_accelerometer_logging.c in called (1). The first step in activation is to check if some conditions are fulfilled. The function returns an error code if acceleration logging is already active or if it is called on a sensor which does not include an LIS2DH12. This check is done by calling find_sensor() inside of app_sensor.c (2). This function return the sensor context. The sensor context consists of several information abut the sensor. In the next step assiciates the function on_fifo_full() from app_accelerometer_logging.c with the interrupt pin retrieved from the sensor context (3). The last step is to activate FIFO and interrupt generation inside the LIS2DH12. This is done by calling two functions from the sensor context. At least the function pointer to data_get() inside the sensor context is replaced by the pointer to the function lis2dh12_logged_data_get(). 3.2 Retrieving data from FIFO When FIFO is full inside LIS2DH12 the interrupt starts the function on_fifo_full(). This functions does not directly handle the new data. It schedules a call to fifo_full_handler(). Instead of on_fifo_full() this is called in the main thread of the application. When processing is done inside a function inside an interrupt context this prevents processing of other interrupt. This should be avoided. Inside fifo_full_handler() the FIFO from LIS2DH12 is read (5). The values are store in the memory in raw format to be ready to present them to the function lis2dh12_logged_data_get() which is important for heartbesat. In parallel the raw values are compacted by removing all unused bits. This is done by the functions pack8/10/12(). A timestamp is added to the compacted values. These values are handover to the ringbuffer which writes them to flash (6). 3.3 Using the data by hearbeat This usecase is shown with magenta arrows and numbers inside magenta circles in the figure above. The heartbeat retrieves the values from all sensors by calling the function app_sensor_get() inside the module app_sensors.c. In the original setup this function calls ri_lis2dh12_data_get() inside of ruuvi_interface_lis2dh12.c. During initialization this function is replaced by lis2dh12_logged_data_get(). lis2dh12_logged_data_get() retrieves the raw accleration values from memory. Then the values are parsed by calling ri_lis2dh12_raw_data_parse() and returned to the heartbeat. 3.4 Initialization during boot All sensor initialization is done inside setup() from main.c. This function calls app_acc_logging_init() inside app_accelerometer_logging.c. The function checks if the ringbuffer exists. If this is true it activates acceleration logging as described earlier. 3.5 Implementation 3.5.1 app_accelerometer_logging.c 3.5.1.1 rd_status_t app_enable_sensor_logging(void) Enables the logging of acceleration data. Special error codes RD_ERROR_INVALID_STATE When logging is already enabled. RD_ERROR_NOT_FOUND When LIS2DH12 is not available. 3.5.1.2 rd_status_t app_disable_sensor_logging(void) Disables the logging of acceleration data. Special error codes || - || RD_ERROR_INVALID_STATE | When logging is already disabled. | RD_ERROR_NOT_FOUND | When LIS2DH12 is not available. | 3.5.1.3 void on_fifo_full (const ri_gpio_evt_t evt) Callback function when FIFO full interrupt occurs at LIS2DH12. This functions schedules the execution of void fifo_full_handler (void * p_event_data, uint16_t event_size). See ruuvi_interface_scheduler.h for parameters used in this function. 3.5.1.4 void fifo_full_handler (void * p_event_data, uint16_t event_size) This functions reads the FIFO and stores the data inside the ringbuffer. See ruuvi_interface_scheduler.h for parameters used in this function. 3.5.1.5 void pack8/10/12(const uint16_t sizeData, const uint8_t* const data, uint8_t* const packeddata) These functions store raw accelerometer values in 8/10/12 Bit format in compact form (without unused bits). Parameters sizeData in Size of input data. data in Input data. packeddata in/out Memory for storing compacted data. 3.5.1.6 rd_status_t lis2dh12_logged_data_get (rd_sensor_data_t * const data) This functions retrieves raw accelerometer values from RAM. The values are parsed and returned inside data. It is called by app_sensor_get() inside app_sensor.c when accelerometer logging is active. Parameters raw_data in/out Memory for storing accelerometer values. 3.5.1.7 rd_status_t app_acc_logging_send_last_sample(const ri_comm_xfer_fp_t reply_fp) This function is called when a request to send the last sample is received by GATT/UART. It retrieves the last sample from RAM, does the compacting of the bits by calling pack8/10/12() and sends the data to the requestor. Parameters reply_fp in Function pointer to reply function. Special error codes || - || RD_ERROR_INVALID_STATE | When logging is not active. | 3.5.1.8 rd_status_t app_acc_logging_state(void) This function is used to query the state of accelerometer logging. It is called when a control message is received by GATT/UART to return this state to the caller. Special error codes || - || RD_SUCCESS | When logging is active. | RD_ERROR_INVALID_STATE | When logging is not active. | 3.5.1.9 rd_status_t app_acc_logging_configuration_set (rt_sensor_ctx_t* sensor, rd_sensor_configuration_t* new_config) This function is called when a request to update the sensor configuration is received by GATT/UART. It checks every configuration parameter if it should be changed. It also checks if the value is different than actual value. If a change is detected it clears the ringbuffer, updates the configuration and stores the configuration in flash. Parameters sensor in Sensor context of the sensor which configuration should be changed. new_config in Structure containing the new configuration values. 3.5.1.10 rd_status_t app_acc_logging_init(void) Initialize acceleration logging during boot. When logging was active before reboot it will be activated. When logging was not active before reboot this function return RD_SUCCESS without activating acceleration logging. The state if logging was active before reboot is detected by looking for the ringbuffer. When the ringbuffer exists, the logging must be active before reboot. This function is called from main.c / setup(). 3.5.1.11 rd_status_t app_acc_logging_uninit(void) The uninitialization of acceleration logging disables the logging when it is actually active. When logging is not active this function return RD_SUCCESS without doing anything. 3.5.2 app_comms.c 3.5.2.1 void handle_comms (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) Added new switch/case which forwards messages regarding configuration and control to the function handle_lis2dh12_comms(). 3.5.2.2 rd_status_t handle_lis2dh12_comms (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) This function handles the GATT/UART communication needed to control the functionality of acceleration logging. Parameters reply_fp in Function pointer to reply function. raw_message in Message received. data_len in Length of the received message. 3.5.3 app_config.h Added macro APP_SENSOR_LOGGING to control compilation of app_accelerometer_logging.* When APP_SENSOR_LOGGING is not defined or is defined as 0 the functionality of logging of acceleration data is not available in the application. 3.5.4 app_heartbeat.c 3.5.4.1 void heartbeat (void * p_event, uint16_t event_size) When acceleration logging is activated, than logging of environmental data is disabled to avoid extreme fragmentation of flash memory. 3.5.5 app_sensor.c 3.5.5.1 rt_sensor_ctx_t* app_sensor_find (const char *name) Find sensor by it’s name. Works only with initialized sensors, will not return a sensor which is supported in firmware but not initialized. This function is called by app_enable_sensor_logging() / app_disable_sensor_logging() to retrieve the sensor context. Parameters name in Name of the sensor. 3.5.6 main.c 3.5.6.1 `void setup (void)’ Added call to app_acc_logging_init() to initialize acceleration logging when desired. 3.5.7 ruuvi_interface_lis2dh12.c 3.5.7.1 rd_status_t ri_lis2dh12_acceleration_raw_get (uint8_t * const raw_data) This functions read raw acceleration values from the registers of LIS2DH12. It is called from the interrupt handler inside app_accelerometer_logging and from ri_lis2dh12_data_get() inside this module. Parameters raw_data in/out Memory for storing raw accelerometer values. 3.5.7.2 rd_status_t ri_lis2dh12_data_get (rd_sensor_data_t * const data) The original function ri_lis2dh12_data_get() is split into retrieving raw values from the sensor and parsing these data. Parsing is done by ri_lis2dh12_raw_data_parse(). This function is used when the acceleration logging is not active. When acceleration logging is active this function is replaced by lis2dh12_logged_data_get() inside app_accelerometer_logging.c. Parameters data in/out Structure for storing parsed accelerometer values. 3.5.7.3 rd_status_t ri_lis2dh12_raw_data_parse (rd_sensor_data_t * const data, axis3bit16_t *raw_acceleration, uint8_t *raw_temperature) This function parses raw values from the sensor and stores the values inside data. It is called from ri_lis2dh12_data_get() and from lis2dh12_logged_data_get(). Parameters data in/out Structure for storing parsed accelerometer values. Raw_acceration in Raw acceleration values. Raw_temperature in Raw temperature value. When used from app_accelerometer_logging.c this parameter is NULL. 3.5.8 ruuvi_nrf5_sdk_rtc_mcu.c 3.5.8.1 rd_status_t ri_set_rtc_millis(uint64_t millis) Set system time by external source. Set RTC to zero. Parameters millis in External time. "],["gateway.html", "Chapter 4 Gateway", " Chapter 4 Gateway Lorem ipsum "],["backend.html", "Chapter 5 Backend", " Chapter 5 Backend Lorem ipsum "],["sensor-1.html", "Chapter 6 Sensor 6.1 Hardware 6.2 Software", " Chapter 6 Sensor 6.1 Hardware 6.1.1 External Flash Memory For more extensive data logging external memory (not in the SoC) is required. The most promising candidate is the Macronix MX25R as it supports low power battery driven applications, is quite flexible in terms of required voltage and is also used in some newer Nordic reference designs. 6.1.2 Board Redesign The current sensor board revision features two antennas, while the bluetooth antenna is required and onboard NFC antenna is not used, therefore the board footprint could be smaller. Inspiration for a board revision could be drawn from the discontinued nRF51822 Bluetooth Smart Beacon Kit reference design. 6.2 Software 6.2.1 General ToDo Remotely customizing the Heartbeat interval (persistence required) Flexibilizing the Logging Rate so that it can be precisely controlled and the sensor supports rates that the accelerometer does not support natively (e.g. 2 Hz) Adapted Advertisement Message Format: Indicate amount of used internal storage to be used by the gateway to trigger connections and manage dowloading of logged data. 6.2.2 Security Questions: * Can Advertisements be encrypted? * How to manage access for downloading internally stored data and allow for encrypted transportation? "],["gateway-1.html", "Chapter 7 Gateway 7.1 Hardware 7.2 Software", " Chapter 7 Gateway 7.1 Hardware 7.1.1 Uninterruptible Power Supply For operating in remote environments the gateway should be equipped with a Uninterruptible Power Supply (UPS). This allows tolerating short power outages and should be configurable to user alternative energy sources such as solar panel or wind turbines to allow for autonomous operation. The most promising products are: * PiJuice Hat * Sixfab UPS Power Hat * UPS PIco HV4.0B Advanced Questions: * How to work with unregulated power sources such as cheap/raw solar panels? * Which UPS provides the best software (Free/Open/Functionality/Reliability)? 7.1.2 Camera A camera is required to record a video stream that is used to derive the ground truth for classification tasks. Use cases can be extended to perform analytics based on the captured images or the video stream. 7.1.2.1 RPi Camera The main camera for the gateway will be the original camera module offered by the Raspberry Pi Foundation, which provides the benefit of an actively maintained software interface and guaranteed compatibility with the used Single Board Computer (SBC). Additionally it is available in two versions, a normal and a NoIR (Night Vision) Version. Questions: * How to match the video feed with the data that is received via Bluetooth? * Which illumination is required for the NoIR Version? * Is it possible to mechanically align the angles (perfect Video overlay) and use both camera versions simultaneously? 7.1.2.2 Thermal Camera For some use cases it may be reasonable to monitor temperatures via a thermal camera. The thermal camera should be seen as an optional addition to the gateway. Questions: * Which module should be chosen in terms of features (especially resolution and connection) and size? * How to align images from all installed cameras (perfectly aligned video stream)? 7.1.3 3g/4g/5g Module Autonomous operation requires a network connection for control and (at least partial) data transfer. Questions: * Which module can be used solely via the GPIO Header (no USB Cable)? * Which module offers the best software interaface( Free/Open/Functionality/Reliability)? 7.1.4 Bluetooth Hardware Alternating and/or extending the Bluetooth Hardware serves two purposes. Having multiple bluetooth devices should allow for monitoring more sensors simultaneously. Including at least one device with support for external antennas would also allow for increased range. Achieving this goal could can be done using at least one (but potentially both) of the following measures: Adding external Bluetooth Hardware Changing the Single Board Computer (SBC) 7.1.5 Case Heat Sink / Active Ventilation 7.2 Software Scheduling and parallelizing download of logged Data "],["backend-1.html", "Chapter 8 Backend", " Chapter 8 Backend Lorem ipsum "],["contributors.html", "Contributors WS 2020 / 2021 SS 2021", " Contributors List of Contributors WS 2020 / 2021 AS FH TH VB SS 2021 "],["system-info.html", "System Info", " System Info Sys.time() ## [1] &quot;2021-02-11 17:00:46 UTC&quot; sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.7 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] kableExtra_1.3.1 knitr_1.31 ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.21 viridisLite_0.3.0 digest_0.6.27 R6_2.5.0 ## [5] lifecycle_0.2.0 magrittr_2.0.1 scales_1.1.1 evaluate_0.14 ## [9] httr_1.4.2 rlang_0.4.10 stringi_1.5.3 rstudioapi_0.13 ## [13] xml2_1.3.2 rmarkdown_2.6 webshot_0.5.2 tools_4.0.3 ## [17] stringr_1.4.0 glue_1.4.2 munsell_0.5.0 xfun_0.21 ## [21] yaml_2.2.1 compiler_4.0.3 colorspace_2.0-0 rvest_0.3.6 ## [25] htmltools_0.5.1.1 "]]
