[["index.html", "Big Data Case Studies Chapter 1 Introduction", " Big Data Case Studies Benjamin Buchwitz 2022-01-19 Chapter 1 Introduction This repo contains course materials. "],["getting-started.html", "Chapter 2 Getting Started 2.1 Sensor Dev Env 2.2 Gateway Dev Env", " Chapter 2 Getting Started Wow content Move on 2.1 Sensor Dev Env This Chapter is a short guide for setting up your development environment. Until you receive your hardware you can start with installing the necessary software. 2.1.1 Software Setup Download “Segger Embedded Studio for ARM 5.10d” (https://www.segger.com/downloads/embedded-studio) Download nRF5_SDK_15.3.0_59ac345.zip (https://developer.nordicsemi.com/nRF5_SDK/nRF5_SDK_v15.x.x/) Clone https://github.com/bchwtz-fhswf/ruuvi.firmware.c. Copy the extracted ZIP from 2. Inside the cloned folder (If you don’t know how to clone a git repository look at https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository or search on google/youtube) It should look like this: Open SEGGER and click “File” -&gt; “Open Solution”, navigate to the cloned repository and open “ruuvi.firmware.c”. The project should now be inside SEGGER. Search “Project ‘ruuvitag_b’” on the left inside SEGGER, right-click and choose “Set as Active Project”. 2.1.2 Hardware Setup Open your ruuvi tag, take PCB &amp; battery out (you can do so with a little screwdriver or by gently pulling on the battery clip) Connect the “Tag Connector” cable + plug to your ruuvi tag Connect the other side of the tag connector to the Debug out slot on the Nordic SDK Connect your SDK over USB with your PC Turn on the switch at the bottom left To test if everything is right, open SEGGER and click “Target”-&gt;”Connect J-Link”. SEGGER should connect to your SDK To flash your ruuvi tag with the cloned firmware, click “Target”-&gt;”Erase All”, afterwards click “Build”-&gt;”Build and Run” 2.2 Gateway Dev Env 2.2.1 Raspberry connection via screen Connect your Raspberry Pi to a screen via Micro HDMI if you have an external screen. Connect your Raspberry to your WiFi Activate SSH and VNC by clicking on the raspberry on the top left -&gt; Preferences -&gt; Raspberry-Pi-Configuration-&gt;Interfaces, change SSH and VNC to activated Skip next steps and jump directly to number 9! 2.2.2 Raspberry connection without a screen (headless setup) Documentation follows this video: https://www.youtube.com/watch?v=rGygESilg8w Take the SD-card of the Raspberry and put it in the card reader of your PC. Go to https://www.raspberrypi.com/software/ and download the Raspberry Pi OS Imager if not yet installed. Open Raspberry Pi Imager. Install operating system and choose the Raspberry Pi OS (normally recommended). Choose your SD card as storage and click “WRITE”. 2.2.3 Set up PuTTY and finalize connection to Raspberry On your PC, download PuTTY (https://www.putty.org/) Get your Raspberry’s IP-Adress by opening a command line on your PC and and type ping raspberrypi.local Open PuTTY, type the IP-Adress into the Host Name field. You can save it by entering a name into the “Saved Sessions” field and pressing “save”. Afterwards select “open”. When asked for the username type pi and afterwards enter your password. If you did not change it on Raspberry’s startup it should be raspberry To clone the Gateway repository (https://github.com/bchwtz-fhswf/gateway) onto your pi, you need a SSH Key which is connected to your account. Generate it by following the instructions in https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent for Linux (you dont have to pass it to a key agent) and add it to your account by following the instructions in https://docs.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account Clone the gateway repository to your raspberry by typing git clone git@github.com:bchwtz-fhswf/gateway.git into the PuTTY window connected to your raspberry. When asked, enter the SSH Key password you initiated while generating the key. Before you are able to execute some of the scripts, you have to install some Python modules by typing or pasting the following commands. (You can paste into a PuTTY window by right-clicking) pip3 install ruuvitag_sensor pip3 install crcmod pip3 install pygatt pip3 install interruptingcow sudo apt-get install bluez bluez-hcidump To try if your setup is working, navigate to the cloned repo and type “python3 GetConfigFromSensor.py”. You should see something like this: To properly use the gateway library, type “python3” into the putty command window. This activates an interactive python session. Type import SensorGatewayCommunication Afterwards you can type test=SensorGatewayCommunication.RuuviTagAccelerometerCommunication() test.activate_logging_at_sensor() Wait a few seconds and type test.get_last_sample_acceleration_data() Wait 2 minutes and type abc=test. get_acceleration_data () You should see some x,y and z acceleration data after executing the get_last_sample_acceleration_data function. After get_acceleration_data, you should see a lot of hex data flooding through your screen. They get saved inside a .csv file for further analysis. CONGRATULATIONS! YOUR SETUP IS READY!!! sudo apt-get install libatlas-base-dev sudo apt-get install python3-pandas sudo apt-get install python3-numpy "],["setup-a-jupyterhub-on-your-raspberrypi.html", "Chapter 3 Setup a Jupyterhub on your RaspberryPi 3.1 Prepare Python environment 3.2 Install JupyterHub 3.3 Configure JupyterHub as a system service", " Chapter 3 Setup a Jupyterhub on your RaspberryPi This chapter is based on the Setup-Guide by Gerold Busch. The following steps must be followed in chronological order to ensure that the JupyterHub works properly: Prepare Python Environment Install JupyterHub Configure JupyterHub as a system service Note It is recommended to change the default password and the default user name when setting up the RaspberryPi for the first time. If there are several RaspberryPis in the network, the hostname should also be changed to simplify a later connection via ssh. The hostname is important to address the Pi if the network assigns dynamic IP addresses. 3.1 Prepare Python environment Redirect the system to python3: sudo rm /usr/bin/python sudo ln -s /usr/bin/python3 /usr/bin/python Install the python package manager pip: sudo apt-get update sudo apt-get install python3-pip sudo pip3 install --upgrade pip 3.2 Install JupyterHub Install the proxy to routes the user requests to the hub and the notebook server: sudo apt-get install npm sudo npm install -g configurable-http-proxy Install JupyterHub and Jupyter Notebook system-wide: sudo -H pip3 install notebook jupyterhub Create a JupyterHub configuration file: jupyterhub --generate-config sudo mv jupyterhub_config.py /root In order to make changes at the Jupyterhub application, modify the /root/jupyterhub_config.py-File. E.g. to change the port on which the JupyterHub runs, uncomment and modify the following line of the config file: c.JupyterHub.bind_url = &#39;http://:8888&#39; 3.3 Configure JupyterHub as a system service To register JupyterHub as a system service, create the file /lib/systemd/system/jupyterhub.service and fill it with: [Unit] Description=JupyterHub Service After=multi-user.target [Service] User=root ExecStart=/usr/local/bin/jupyterhub --config=/root/jupyterhub_config.py Restart=on-failure [Install] WantedBy=multi-user.target Make sure that the line starting with ExecStart contains the correct location of the JupyterHub binary and the config-file. Afterwards, run the following commands: sudo systemctl daemon-reload sudo systemctl start jupyterhub sudo systemctl enable jupyterhub sudo systemctl status jupyterhub.service Now the JupytherHub should be accessible under the link: http://&lt;address of your raspi/hostname&gt;:8888 Note This chapter did not include the data transfer to the RaspberryPi. It is recommended to clone the repository on the RaspberryPi or to copy the local files between the computer and the Pi via scp command or VNC. "],["pycharm.html", "Chapter 4 PyCharm 4.1 PyCharm Git Repository 4.2 RemoteDeploy", " Chapter 4 PyCharm PyCharm is a Python IDE from JetBrains which offers nice features like Remote Deploy and repository management. For students PyCharm is free to use. You just must make a user account with your university Email on the JetBrains website. 4.1 PyCharm Git Repository Open a new Project. Go to VCS and select Get from Version Control Click on GitHub Click on Login via GitHub You get redirected to a JetBrains site. 6. Click on “Authorize in GitHub” Enter your credentials If it is successful choose the gateway repository from the list and click “clone”. If the Error message “Git is not installed” appears you can click on it to install on your machine. After git is installed you have to repeat the steps 2. 3. 7. Afterwards your IDE should looks like this: You can now work within the gateway code. To change the branch, where you are working, go to the right bottom corner of PyCharm. And click on the “branch” symbol. All branches in the repository are shown pick your branch and press Checkout. 4.2 RemoteDeploy To run the code on your raspberry pi you must make a remote deploy connection. We show you how to do this in this chapter: Open Tools Choose Deployment Click on Configutarion Press the plus sign in the top left corner of the deployment window: Choose SFTP and give the server a name. Press the “…” Button next to SSH configuration and press the plus sign in the top left corner. Now enter the Ip from your pi. Which you can find out with Chaper XX. Enter the pi User name and your pi password. Test the connection with the Test Conenction Button. Accept the upcoming windows. If the connection is successful press the ok button. Now we must choose the deployment path. Change to the mappings tab and click on the folder Symbol next to Deployment Path: Choose your file path via dropdown. Note the file must be in the home directory to prevent failures. Click File &gt; Settings Go to Python Interpreter and click the sprocket on the right sight Choose add and click on SSH Interpreter and tick Existing Server configuration. Choose your ssh connection and click next Change your Sync folder. Click on Folder icon on the right side Click on the Remote Path side again on the Folder Symbol Select your path from 9 Click ok buttons until your back on your main screen. If installations are requiered press the „Install requirements in the top right corner Now you can run the code on remote. All changes will be transmitted automatically to the raspberry pi "],["getting-started-package.html", "Chapter 5 Getting Started Package 5.1 Raspbery Pi OS “Buster” 5.2 Board", " Chapter 5 Getting Started Package 5.1 Raspbery Pi OS “Buster” 5.2 Board 5.2.1 Raspberry Pi 4 - Model B 5.2.2 Compute Model 4 5.2.2.1 Enabling USB Ports The USB 2.0 ports on the Wavesahre Baseboard A are disabled by default. To enable those ports the following commands need to be added to the end of /boot/config.txt. dtoverlay=dwc2,dr_mode=host The system needs to be rebooted to make the USB 2.0 ports work. 5.2.2.2 Enabling Camera &amp; DSI Port sudo apt-get install p7zip-full wget https://www.waveshare.com/w/upload/4/41/CM4_dt_blob.7z 7z x CM4_dt_blob.7z -O./CM4_dt_blob sudo chmod 777 -R CM4_dt_blob cd CM4_dt_blob/ #If you want to use both cameras and DSI0 sudo dtc -I dts -O dtb -o /boot/dt-blob.bin dt-blob-disp0-double_cam.dts #If you want to ue both cameras and DSI1 sudo dtc -I dts -O dtb -o /boot/dt-blob.bin dt-blob-disp1-double_cam.dts "],["sensor.html", "Chapter 6 Sensor 6.1 Initializing acceleration logging 6.2 Retrieving data from FIFO 6.3 Using the data by hearbeat 6.4 Initialization during boot 6.5 Streaming of acceleration data 6.6 Implementation 6.7 Energy consumption 6.8 Firmware packaging", " Chapter 6 Sensor The following figure shows the high level architecture of acceleration data logging in Ruuvi Tag. All configuration is done via the gateway. It communicates with the Ruuvi Tag using the Nordic UART interface via GATT messages transported by Bluetooth Low Energy (BLE). Most logic regarding acceleration logging is implemented inside the module app_accelerometer_logging.c. Three use cases are shown in this figure. 6.1 Initializing acceleration logging The initialization is shown with blue arrows and numbers in black circles until #4. To activate acceleration logging the gateway sends the control acceleration logging message. In general GATT messages are handled by the function handle_comms() inside the module app_comm.c. Messages regarding acceleration logging are delegated to the function handle_lis2dh12_comms_v2() inside the same module. After receiving the message to activate acceleration logging the function app_enable_sensor_logging() inside the module app_accelerometer_logging.c in called (1). The first step in activation is to check if all conditions are fulfilled. The function returns an error code if acceleration logging is already active or if it is called on a sensor which does not include an LIS2DH12. This check is done by calling find_sensor() inside of app_sensor.c (2). This function returns the sensor context. The sensor context consists of several information about the sensor. The next step associates the function on_fifo_full() from app_accelerometer_logging.c with the interrupt pin retrieved from the sensor context (3). The last step is to activate FIFO and interrupt generation inside the LIS2DH12. This is done by calling two functions from the sensor context. At last the function pointer to data_get() inside the sensor context is replaced by the pointer to the function lis2dh12_logged_data_get(). 6.2 Retrieving data from FIFO When FIFO is full inside LIS2DH12 the interrupt starts the function on_fifo_full(). This function does not directly handle the new data. It schedules a call to fifo_full_handler(). Instead of on_fifo_full() this is called in the main thread of the application. If processing is done inside a function inside an interrupt context this prevents processing of another interrupt. This should be avoided. Inside fifo_full_handler() the FIFO from LIS2DH12 is read (5). The values are store in memory in raw format to be ready to present them to the function lis2dh12_logged_data_get() which is important for heartbeat. In parallel the raw values are compacted by removing all unused bits. This is done by the function pack(). These values are handover to the FlashDB which writes them to flash (6). 6.3 Using the data by hearbeat This use case is shown with magenta arrows and numbers inside magenta circles in the figure above. The heartbeat retrieves the values from all sensors by calling the function app_sensor_get() inside the module app_sensors.c. In the original setup this function calls ri_lis2dh12_data_get() inside ruuvi_interface_lis2dh12.c. During initialization this function is replaced by lis2dh12_logged_data_get(). lis2dh12_logged_data_get() retrieves the raw acceleration values from memory. Then the values are parsed by calling ri_lis2dh12_raw_data_parse() and returned to the heartbeat. 6.4 Initialization during boot All sensor initialization is done inside setup() from main.c. This function calls app_acc_logging_init() inside app_accelerometer_logging.c. The function checks if the ringbuffer exists. If this is true it activates acceleration logging as described earlier. 6.5 Streaming of acceleration data In case of sampling acceleration data at high sampling frequencies than storing them in flash memory may be not possible because of latency of the memory or limitations by available size of memory. As an alternative the data can be streamed. In this mode, data from the acceleration sensor will not be written to flash. Instead the data is cached in RAM. For this purpose 6k RAM are dynamically allocated using malloc() during enabling of streaming. At the time of writing this documentation FlashDB lacks the feature of freeing memory which is used to store a database. Because of this missing feature the only way of freeing the memory used by streaming is to reboot the firmware. The following figure shows the difference between logging of acceleration data and streaming. When logging is active, the acceleration sensor LIS2DH12 generated an interrupt every time its FIFO is full. The interrupt causes the execution of on_fifo_full(). This function schedules the execution of fifo_full_handler() outside interrupt context (grey). The following process was described earlier. When streaming is active, the process is started by the same condition. But the FIFO is read by on_fifo_full(). Instead of scheduling fifo_full_handler() the function hands over the data to FlashDB which stores them in RAM. This is done inside interrupt context (blue). In case of streaming there is no explicit command to read the data by the gateway. Instead, if connected to Bluetooth GATT service, the data is automatically send. This is done by scheduling app_acc_log_transfer_ram_db(). on_fifo_full() schedules execution of this function if rt_gatt_nus_is_connected() returns true. 6.6 Implementation 6.6.1 app_accelerometer_logging.c 6.6.1.1 rd_status_t app_enable_sensor_logging(const bool use_ram_db, const bool format_db) Enables the logging of acceleration data. Parameters use_ram_db in Database in RAM is used in case of streaming of acceleration data. format_db in This parameter is set to true if logging is enabled by gateway to ensure the database is cleared. When re-enabling logging after reboot it is set to false. Special error codes RD_ERROR_INVALID_STATE If logging is already enabled. RD_ERROR_NOT_FOUND If LIS2DH12 is not available. 6.6.1.2 rd_status_t app_disable_sensor_logging(void) Disables the logging of acceleration data. Special error codes RD_ERROR_INVALID_STATE If logging is already disabled. RD_ERROR_NOT_FOUND If LIS2DH12 is not available. 6.6.1.3 void on_fifo_full (const ri_gpio_evt_t evt) Callback function when FIFO full interrupt occurs at LIS2DH12. If using streaming this function reads the FIFO and writes the values to RAMDB. Without streaming it schedules the execution of void fifo_full_handler (void * p_event_data, uint16_t event_size) to read the FIFO outside interrupt context. See ruuvi_interface_scheduler.h for parameters used in this function. 6.6.1.4 void fifo_full_handler (void * p_event_data, uint16_t event_size) This function reads the FIFO and stores the data inside the timeseries database. See ruuvi_interface_scheduler.h for parameters used in this function. 6.6.1.5 void pack(const uint8_t resolution, const uint16_t sizeData, const uint8_t* const data, uint8_t* const packeddata) This function stores raw accelerometer values in 8/10/12 Bit format in compact form (without unused bits). It is a frontend to the functions pack8/10/12(). Parameters resolution in Resolution of the samples. sizeData in Size of input data. data in Input data. packeddata in/out Memory for storing compacted data. 6.6.1.6 rd_status_t lis2dh12_logged_data_get (rd_sensor_data_t * const data) This function retrieves raw accelerometer values from memory. The values are parsed and returned inside data. It is called by app_sensor_get() inside app_sensor.c if accelerometer logging is active. Parameters raw_data in/out Memory for storing accelerometer values. 6.6.1.7 rd_status_t app_acc_logging_send_eof_v2(const ri_comm_xfer_fp_t reply_fp, const rd_status_t status_code, const uint16_t crc) This function is called by app_acc_logging_send_logged_data() after all data is sent to the requestor. This function builds the end of data message and sends it. Parameters reply_fp in Function pointer to reply function. status_code in Status code of the whole operation. This code is sent to the requestor. crc in CRC value of the data. 6.6.1.8 rd_status_t app_acc_logging_send_logged_data(const ri_comm_xfer_fp_t reply_fp) This function is called when a request to send the logged acceleration data is received by GATT/UART. The function triggers FlashDB to read data. Data from the database is read via the callback function callback_send_data_block(). Inside the callback function the data is send to the requestor. Parameters reply_fp in Function pointer to reply function. Special error codes RD_ERROR_INVALID_STATE If logging is not active. 6.6.1.9 rd_status_t app_acc_logging_state(void) This function is used to query the state of accelerometer logging. It is called when a control message is received by GATT/UART to return this state to the caller. If streaming is active, this will not be reported as active logging by this function. Special error codes RD_SUCCESS If logging is active. RD_ERROR_INVALID_STATE If logging is not active. 6.6.1.10 rd_status_t app_acc_logging_configuration_set (rt_sensor_ctx_t* sensor, rd_sensor_configuration_t* new_config) This function is called when a request to update the sensor configuration is received by GATT/UART. It checks every configuration parameter if it should be changed. It also checks if the value is different than actual value. If a change is detected it clears the ringbuffer, updates the configuration and stores the configuration in flash. Parameters sensor in Sensor context of the sensor which configuration should be changed. new_config in Structure containing the new configuration values. 6.6.1.11 rd_status_t app_acc_logging_init(void) Initialize acceleration logging during boot. If logging was active before reboot it will be activated. If logging was not active before reboot this function return RD_SUCCESS without activating acceleration logging. This function is called from setup(). 6.6.1.12 rd_status_t app_acc_logging_uninit(void) The uninitialization of acceleration logging disables the logging if it is actually active. If logging is not active this function return RD_SUCCESS without doing anything. 6.6.1.13 void app_acc_log_transfer_ram_db (void * p_event_data, uint16_t event_size) Execution of this function is scheduled if “streaming” is active and rt_gatt_nus_is_connected() returns true. It starts reading currently logged data from the FlashDB and transferring the data to the gateway. Scheduling of this function is done inside on_fifo_full() using ri_scheduler_event_put(). 6.6.1.14 int64_t fdb_timestamp_get (void) Callback for use by FlashDB to retrieve the timestamp of the current new entry. 6.6.1.15 bool callback_send_data_block(fdb_tsl_t tsl, void *arg) Callback function for use with FlashDB. When reading the database this function will be called for every entry. This function calls app_comms_blocking_send() to send the data to the gateway. Parameters tsl in Pointer to current entry in the database. arg in/out Pointer to context. See following table. The array consists of the following elements. Context parameters by *arg ((void**)arg)[0] in Pointer to database of type fdb_tsdb*. ((void**)arg)[1] in Pointer to transfer function app_comms_blocking_send(). ((void**)arg)[2] in/out Pointer to CRC value. If this functions returns true iterating over the following entries will by aborted. 6.6.1.16 rd_status_t app_acc_logging_statistic (uint8_t* const statistic) This function is called from handle_lis2dh12_comms() after the gateway sends the message to retrieve flash statistics. Parameters statistic in/out Memory to store the statistic values. 6.6.1.17 uint8_t ruuvi_error_code_to_uint8(rd_status_t err_code) This function converts an Ruuvi error code to a one byte value. It returns the bit index of first error it finds. It cannot return a set of multiple errors as the input value supports. Parameters err_code in Ruuvi error code. 6.6.2 app_comms.c 6.6.2.1 void handle_comms (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) Added new switch/case which forwards messages regarding configuration and control of acceleration logging to the function handle_lis2dh12_comms(), handle_lis2dh12_comms_v2(), handle_rtc_comms(). 6.6.2.2 rd_status_t handle_lis2dh12_comms (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) This function handles messages using the proprietary message format by GATT/UART communication needed to control the functionality of acceleration logging. Parameters reply_fp in Function pointer to reply function. raw_message in Message received. data_len in Length of the received message. Special error codes RD_ERROR_NOT_FOUND If LIS2DH12 is not found. RD_ERROR_INVALID_PARAM If unknown or invalid message was received. 6.6.2.3 rd_status_t handle_lis2dh12_comms_v2 (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) This function handles messages using version 2 message format by GATT/UART communication needed to control the functionality of acceleration logging. Parameters reply_fp in Function pointer to reply function. raw_message in Message received. data_len in Length of the received message. Special error codes RD_ERROR_NOT_FOUND If LIS2DH12 is not found. RD_ERROR_INVALID_PARAM If unknown or invalid message was received. 6.6.2.4 rd_status_t handle_rtc_comms (const ri_comm_xfer_fp_t reply_fp, const uint8_t * const raw_message, size_t data_len) This function handles messages using version 2 message format by GATT/UART communication needed to control the RTC clock. Parameters reply_fp in Function pointer to reply function. raw_message in Message received. data_len in Length of the received message. Special error codes RD_ERROR_INVALID_PARAM If unknown or invalid message was received. 6.6.2.5 rd_status_t dis_init (ri_comm_dis_init_t * const p_dis, const bool secure) This function is called during initialization of the Bluetooth protocol stack. Our extension to this function is executed if app_sensor_ctx_get() from app_sensors.c is available. It sets the hardware revision string inside ri_comm_dis_init_t to the list of available and initialized sensors. 6.6.3 ruuvi_nrf5_sdk15_communication_ble_gatt.c 6.6.3.1 rd_status_t ri_gatt_dis_init (const ri_comm_dis_init_t * const p_dis) This function is called during initialization of the Bluetooth protocol stack. Our extension to this function adds a buildnumber to the former unused property sw_rev_str of ble_dis_init_t. The buildnumber is generated by a pre-build script buildnum.js which is executed by Segger Embedded Studio before compiling the software. The pre-buold script generated buildnum.h which includes the buildnumber. 6.6.4 app_config.h Added macro APP_SENSOR_LOGGING to control compilation of app_accelerometer_logging.* If APP_SENSOR_LOGGING is not defined or is defined as 0 the functionality of logging of acceleration data is not available in the application. Changed the definition of APP_FLASH_PAGES to include the flash pages used for acceleration logging. This module also contains macros for memory separation between acceleration logging and environmental logging. The relevant macros are APP_FLASH_LOG_DATA_RECORDS_NUM and RT_FLASH_RINGBUFFER_MAXSIZE. 6.6.5 app_sensor.c 6.6.5.1 rt_sensor_ctx_t* app_sensor_find (const char *name) Find sensor by its name. Works only with initialized sensors, will not return a sensor which is supported in firmware but not initialized. This function is called by app_enable_sensor_logging() and app_disable_sensor_logging() to retrieve the sensor context. Parameters name in Name of the sensor. 6.6.6 main.c 6.6.6.1 void setup (void) Added call to app_acc_logging_init() to initialize acceleration logging. 6.6.7 ruuvi_interface_lis2dh12.c 6.6.7.1 rd_status_t ri_lis2dh12_acceleration_raw_get (uint8_t * const raw_data) This function reads raw acceleration values from the registers of LIS2DH12. It is called from the interrupt handler inside app_accelerometer_logging.c and from ri_lis2dh12_data_get(). Parameters raw_data in/out Memory for storing raw accelerometer values. 6.6.7.2 rd_status_t ri_lis2dh12_temperature_raw_get (uint8_t * const raw_temperature) This function reads raw temperature value from the registers of LIS2DH12. It is called ri_lis2dh12_data_get() and lis2dh12_logged_data_get(). Parameters raw_temperature in/out Memory for storing raw temperature values. 6.6.7.3 rd_status_t ri_lis2dh12_data_get (rd_sensor_data_t * const data) The original function ri_lis2dh12_data_get() is split into retrieving raw values from the sensor and parsing these data. Parsing is done by ri_lis2dh12_raw_data_parse(). This function is used if the acceleration logging is not active. If acceleration logging is active this function is replaced by lis2dh12_logged_data_get(). Parameters data in/out Structure for storing parsed accelerometer values. 6.6.7.4 rd_status_t ri_lis2dh12_raw_data_parse (rd_sensor_data_t * const data, axis3bit16_t *raw_acceleration, uint8_t *raw_temperature) This function parses raw values from the sensor and stores the values inside data. It is called from ri_lis2dh12_data_get() and from lis2dh12_logged_data_get(). Parameters data in/out Structure for storing parsed accelerometer values. raw_acceleration in Raw acceleration values. raw_temperature in Raw temperature value. This parameter can be NULL. 6.6.8 ruuvi_nrf5_sdk_rtc_mcu.c 6.6.8.1 rd_status_t ri_set_rtc_millis(uint64_t millis) Set system time by external source. Set RTC to zero. Parameters millis in External time. 6.6.9 ruuvi_nrf5_sdk15_power.c / ruuvi_nrf5_sdk15_power.h 6.6.9.1 rd_status_t ri_power_read_boot_count (uint32_t *boot_count) This function return the boot counter. Parameters boot_count out Memory for storing the boot counter. 6.6.10 ruuvi_task_flash_ringbuffer.c The ringbuffer module acts as a frontend to FlashDB. The ringbuffer functionality is provided by the timeseries database of FlashDB. 6.6.10.1 rd_status_t rt_flash_ringbuffer_create(const char *partition, fdb_get_time get_time, const bool format_db) This function initializes an instance of timeseries database. Parameters partition in Name of the partition of the FAL device where the database will be stored. get_time in Function pointer to callback function. This function is used by timeseries database to retrieve the current timestamp. format_db in Wether to force to create a empty database. 6.6.10.2 rd_status_t rt_flash_ringbuffer_write(const uint16_t size, const void* data) This function writes data to FlashDB. Parameters size in Size of data data in Data to be written 6.6.10.3 rd_status_t rt_flash_ringbuffer_read(const fdb_tsl_cb callback, const ri_comm_xfer_fp_t reply_fp, uint16_t* crc) This function starts reading the timeseries database. Reading data from timeseries database is done by iterating all entries. For every entry a callback function is called. Parameters callback in Callback function which would be called for every entry. reply_fp in Callback function which sends the data to the requestor. crc in/out CRC16 value which gets calculated over all data send to the requestor. 6.6.10.4 rd_status_t rt_flash_ringbuffer_clear(void) This function clears the contents of the timeseries database. 6.6.10.5 rd_status_t rt_flash_ringbuffer_drop (void) This function de-initializes the timeseries database. 6.6.10.6 rd_status_t rt_flash_ringbuffer_statistic (uint8_t* const statistic) This function reads some statistics about the usage of the internal Nordic Flash memory and returns them. Parameters statistic in/out Memory for storing statistics. 6.6.11 ruuvi_task_flashdb.c This module contains supporting functions needed to integrate FlashDB into Ruuvi Firmware. 6.6.11.1 rd_status_t rt_macronix_flash_exists(void) This function checks if Macronix Flash Chip is available. Special error codes RD_SUCCESS If Macronix Flash is available. RD_ERROR_NOT_FOUND If Macronix Flash is not available. RD_ERROR_NOT_INITIALIZED If the module is currently not initialzed. 6.6.11.2 rd_status_t rt_flashdb_to_ruuvi_error(fdb_err_t fdb_err) This function converts an error code of FlashDB to an Ruuvi error code. It return the Ruuvi error code which represents the state of FlashDB. Parameters fdb_err in Error code of FlashDB. 6.6.11.3 rd_status_t rt_reset_macronix_flash(void) This functions sends the Chip Erase command to the macronix flash chip if the chip is available. This function is called during factory reset. 6.6.11.4 rt_macronix_high_performance_switch(const bool enable) This function configures the high performance switch of the Macronix Flash Chip. High performance mode is used during formating the flash in order to prepare it for the database or during factory reset. Parameters enable in Desired mode of operation. 6.6.11.5 void fdb_log (const char * const msg, ...) This function acts as a proxy between the logging mechanism of FlashDB and the log writing system of Ruvvi. It converts the parameters and passes log messages to Ruuvi’s logging module. 6.6.12 app_button.c 6.6.12.1 void factory_reset (void * p_event_data, uint16_t event_size) Add call to rt_reset_macronix_flash() to delete content of Macronix Flash in case of factory reset. 6.7 Energy consumption The following figure visualizes energy consumption of different operation states. The numbers at the measuring point are equal to the duration. All measurements are done with 3V supply voltage. 6.8 Firmware packaging To create a File which is suitable for DFU you need nrfutil from Nordic Semiconductor. The DFU Package must be signed. The private key can be obtained from Ruuvi’s Github repository. The following script to create a DFU package assumes this directory structure. dfu-package \\ | ruuvi_open_private.pem ruuvi.firmware.c \\ | nRF5_SDK_15.3.0_59ac345 | src | \\ | | output | | \\ | | | debug | | | \\ | | | | exe To create a DFU package execute the following commands inside directory dfu-package. nrfutil settings generate --family NRF52 --application ..\\ruuvi.firmware.c\\src\\Output\\Debug\\Exe\\ruuvitag_b.hex --application-version 1 --bootloader-version 1 --bl-settings-version 1 output\\settings.hex mergehex -m ..\\ruuvi.firmware.c\\nRF5_SDK_15.3.0_59ac345\\components\\softdevice\\s132\\hex\\s132_nrf52_6.1.1_softdevice.hex ruuvitag_b_s132_6.1.1_bootloader_3.1.0.hex output\\settings.hex -o output\\sbc.hex mergehex -m output\\sbc.hex ..\\ruuvi.firmware.c\\src\\Output\\Debug\\Exe\\ruuvitag_b.hex -o output\\packet.hex nrfutil pkg generate --application ..\\ruuvi.firmware.c\\src\\Output\\Debug\\Exe\\ruuvitag_b.hex --application-version 1 --hw-version 0xB0 --sd-req 0xB7 --key-file ruuvi_open_private.pem dfu_app.zip "],["external-flash-integration.html", "Chapter 7 External Flash Integration 7.1 Macronix Flash 7.2 Database vs. Filesystem 7.3 Implementation 7.4 FlashDB evaluation", " Chapter 7 External Flash Integration In this chapter the software architecture for implementing an external flash is described. The ruuvi sensor includes an internal flash with 56 Kbyte. To show the benefit of an external flash, the following example analyzes how long data can be recorded in each case. Using the internal FIFO that has storage space for 32 acceleration data samples and a configuration of: 10 Hz frequency 12 bit of data resolution 144Byte of data are written to the internal flash every 3,2s. That allows logging data for 1244 s. Implementing the external flash from Macronix with a size of 64Mbit and the same configuration as above allows logging for 51,756 h. 7.1 Macronix Flash Next, an overview on general parameters of the Macronix flash is given. The MX25R6435F is a serial NOR flash with 64Mbits. It promises a minimum of 100.000 erase/program cycles and 20 years of data retention. Further, the flash has a status register that indicates its status and a configuration register which can change the default status of the chip. Program commands can be executed on byte, page (256 bytes), or word basis while erase commands can be executed on sector (4K-byte), block (32K-byte), block (64K-byte) or whole chip basis. For testing the “tag connector” is used where the following pins are defined for the SPI bus: SPI PIN MOSI 30 MISO 31 SCK 20 SS 16 When the external flash is included on the PCB, the pins for the SPI bus must change to: SPI PIN MOSI 23 MISO 22 SCK 24 SS 11 The following picture showes the setup: 7.2 Database vs. Filesystem For data management on the flash, a database is needed. An alternative is, to use a file system. For the decision, the following characteristics of each option are considered: Database Filesystem Related, structured data Good with unstructured data Data with defined formats Small overhead Efficient for insert, update and/or retrieval As a first approach, the database FlashDB is used. The acceleration data is structured, the order of the incoming data and its timestamp is of interest. That is provided by the time series data base (TSDB). Another useful functionality is the key value data base (KVDB), supported by the FlashDB, that allows storing the configuration. Also, the KVDB provides efficient storage of pre-processed data, which is a possible requirement in future. 7.2.1 FlashDB “Flash DB is an ultra-lightweight embedded database that focuses on providing data storage solutions for embedded products.” [https://github.com/armink/FlashDB] The DB promotes with a strong performance and reliability including a Power-off protection function and wear balance to extend Flash life. It ensures extremely low resource occupation, ram usage of almost 0 and a very small footprint. Also, multiple partitions and multiple instances are supported. The FlashDB uses sectors which are the smallest unit for formatting. As mentioned above, there are two database modes: Key-value database Non-relational database Stores data as a collection of key-value pairs, with key as unique identifier Supports two KV types: string and blob Time Series database Stores data in time sequence with timestamp Has large amount of data storage and high insertion and query performance. Reference: FlashDB by armink 7.3 Implementation The following chapter is focusing on the software structure, modules and functions successfully utilized to implement the possibility to store data on the external flash by using the database FlashDB. The following figure shows the general structure: The data collected by the acceleration sensor are passed through several instances and finally end in the module “ruuvi_task_flash_ringbuffer.c” which is responsible for organizing the storage of the collected data through usage of the API offered by FlashDB. FlashDB itself needs some configuration, stored inside its config files, to be able to communicate with the different memory devices. Currently, FlashDB can be operated with three different target memories: 1. The internal NRF flash in case the external flash is not present, which gets checked at boot-up 2. The external flash to allow maximized data storage 3. The RAM to allow direct forwarding of acceleration data to the gateway in the use case of streaming (deprecated) As this chapter is discusses the integration of the external Macronix flash chip, the other two devices won’t be considered from here on. For FlashDB to be able to access the external flash, an interface to the low-level driver functions is implemented, which forwards the necessary control parameters to the actual driver functions, which communicate with the flash device via SPI bus. 7.3.1 FlashDB API To administrate the storage independent from the used memory device and from a high-level view, the FlashDB API offers the following functions: TSDB: Initialise Control void fdb_tsdb_control(fdb_tsdb_t db, int cmd, void *arg) Command control words e.g., Set / Get sector size, Set/ Get lock function, Get the timestamp when TSL was last appended Append new TSL Iterative – goes through TSDB, iterative callbacks Query between timestamps Set TSL status Clear TSDB Convert TSL to blob objects KVDB: Initialise Control void fdb_kvdb_control(fdb_kvdb_t db, int cmd, void *arg) Command control words: Set / Get sector size, Set/ Get lock function Set KV (add a new KV or modify existing KV) Set blob type KV, Set string type KV Get KV Get blob type KV, Get KV object, Get string type KV Initialize KV iterator, Iteration Delete KV, Reset KV to default Convert KV to blob objects For more details: FlashDB API 7.3.2 Data Base config files The FlashDB config files are stored in .firmware.c.libraries.c. They implement the necessary configuration to be able to access the different storage modules. 7.3.2.1 fal_cfg.h The fal_cfg file defines the available storage partitions to be used by FlashDB inside the FAL_PART_TABLE. The following figure shows the currently defined partitions and their size, once again stressing the huge amount of more available space when using the external flash in contrast to the internal NRF memory. The small partitions for storing data in the KV format are used for the current sensor configuration while the larger TSDB partitions are utilized to store the acceleration data. 7.3.2.2 fal_macronix_flash_port.c For each of the available memory devices, a flash_port file is defined, which implements the configuration of the device as well as the interface to the low-level driver functions. In the following, the necessary implementations for the external Macronix flash chip are described: 7.3.2.2.1 Const struct fal_flash_dev macronix_flash0 Defines macronix flash properties for FlashDB 1. Name (macronixflash0) 2. Offset Address (0x000000) 3. Memory size (2047*4096 Bytes = 8MB) 4. Block size (4096 Bytes) 5. Write granularity (0 –&gt; not used) 6. Available operations (init, read, write, erase) 7.3.2.2.2 Static int init(void) Calls the mx_init() initialization function. Returns the status of the initialization function. 7.3.2.2.3 Static int read(long offset, uint8_t *buf, size_t size) Forwards address (offset), the address of the target data buffer (*buf) and the amount of data to be read (size) to the according low-level driver function. Returns the read size if successful and –1 if an error occurred. 7.3.2.2.4 Static int write (long offset, const uint8_t *buf, size_t size) Ensures that the flash device is ready for data transfer, by calling write enable, checking if write enable was set properly and checking the status register if the flash is still busy. Also splits the data in multiple separate low-level write function calls if the data is separated over multiple flash pages as the Macronix flash is not supporting writing over page borders. Returns written size if successful, -1 if an error occurred. 7.3.2.2.5 Static int erase (long offset, size_t size) Ensures that the flash device is ready for data transfer, by calling write enable, checking if write enable was set properly and checking the status register if the flash is still busy. Forwards address to “macronix sector erase” low-level driver function. –&gt; Database only deletes complete sectors at once Returns written size if successful, -1 if an error occurred. 7.3.3 Macronix low level driver functions The module “maconix_flash.c/macronix_flash.h” located at .firmware.c.drivers.cimplements all low-level driver and helper functions necessary to interact with the Macronix flash chip. 7.3.3.1 rd_status_t mx_init(void) Checks if SPI bus for macronix flash is already initialized If not, defines * MOSI, MISO, CLK and SS PINs * Frequency, SPI mode and bit order Sets all defined SS-PINs as high (not active) Definition of SPI-Pins can be changed in macronix_flash.h. Returns status code of executed functions, RD_ERROR_INVALID_STATE if bus is already initialized 7.3.3.2 rd_status_t mx_read_rems(uint8_t *manufacturer_id, uint8_t *device_id) Reads electronic manufacturer &amp; device ID by 1. Setting SS LOW 2. Transferring the command “0x90” via SPI 3. Receiving the answer 4. Setting SS HIGH 5. Assigning the values to the received memory Is used to check if the macronix flash is present to decide, which device is used by FlashDB Returns Status code of executed SPI functions 7.3.3.3 rd_status_t mx_read_status_register(uint8_t *status) Reads Macronix status register and assigns the status of the Write-In-Progress Bit to the received pointer Status register also holds: 1. Write Enable Latch bit –&gt; set to “1” by “Write Enable” function and reset to “0” after program/erase function terminated 2. Block Protect 0 – 3 bits 3. Quad Enable bit 4. Status Register Write Disable bit –&gt; shows Hardware protection mode (on PIN WP#SIO2) Returns Status code of executed SPI functions 7.3.3.4 rd_status_t mx_read_config_register(uint8_t *config) Reads Macronix config register and assigns the status of the Low power/High Performance switch bit to the received pointer 1. TB bit –&gt; decides whether protected area is at top or bottom of flash 2. L/H switch bit –&gt; Switch between “Ultra Low Power” and “High Performance” Returns Status code of executed SPI functions 7.3.3.5 rd_status_t mx_read(uint32_t address, uint8_t *data_ptr, uint32_t data_length) Reads from “address” the number of bytes given in “data_length” and returns them inside the “data_ptr”. MX25R only supports reading of 256 Bytes in 1 call –&gt; Loops over multiple read-calls and decreases “data_length” until all desired bytes are read Alternative: FAST_READ to read out data until CS is set to high after just one spi call with command and starting address –&gt; not used as FlashDB is not supporting an option for fast read Returns Status code of executed SPI functions 7.3.3.6 rd_status_t mx_write_enable(void) Sends Write Enable command to flash –&gt; needs to be set before every program/erase command –&gt; if it is “0” while program/erase command is received, MX25R will ignore the command –&gt; can be reset by write disable command, but will be reset after finished program/erase instructions anyhow Returns Status code of executed SPI functions 7.3.3.7 rd_status_t mx_program(uint32_t address, const uint8_t *data_ptr, uint32_t data_length) Writes from “address” the bytes given in “data_ptr”. Returns Status code of executed SPI functions 7.3.3.8 rd_status_t mx_sector_erase(uint32_t address) Erases the sector (4096 Byte) which is containing the given address Is used by FlashDB which is always erasing whole sectors Returns Status code of executed SPI functions 7.3.3.9 rd_status_t mx_chip_erase(void) Erases the whole chip Is used inside rt_reset_macronix_flash() included in ruuvi_task_flash_ringbuffer.c which is called when a ruuvi factory reset is triggered (by pressing the button on the ruuvi tag for ~10 seconds) Returns Status code of executed SPI functions 7.3.3.10 rd_status_t ri_spi_xfer_blocking_macronix(const uint8_t *tx, const size_t tx_len, uint8_t *rx, const size_t rx_len) Base function used to pass data to or receive data from the Macronix Flash Makes a basic NULL-check to verify that given data length is only NULL if no corresponding command is received Only transmits data, if mx_init function is called before (by checking parameter m_spi_init_done) –&gt; Uses nrf_drv_spi_transfer function to communicate with SPI device Returns Status code of executed SPI functions 7.3.3.11 rd_status_t mx_busy(void) Reads status register and returns “RD_ERROR_BUSY” or “RD_SUCCESS” depending on Write-In-Progress bit. Is used by mx_spi_ready_for_transfer. 7.3.3.12 rd_status_t mx_check_write_enable(void) Read status register and return “RD_ERROR_BUSY” or “RD_SUCCESS” depending on Write-Enable-Latch bit. Is used by mx_spi_ready_for_transfer. 7.3.3.13 void mx_spi_ready_for_transfer (void) Waits until flash is not busy Sends write enable command Waits until write enable latch is set, resends write enable command if it is not Waits until flash is not busy Used to prepare the flash device before write or erase commands. 7.3.3.14 rd_status_t mx_high_performance_switch (bool high_power) Reads the config register and sets the Low-Power / High Performance switch to the value received (High Performance if True, Low power if False) if it is not already the expected value. Used to change the power mode to high performance during initialization, discussed in the next chapter. 7.4 FlashDB evaluation The following analysis is done under the configuration described in the introduction ( 12 bit resolution and 10 Hz frequency). One block of the Flash consists of 56 byte of block overhead, each time a 144 byte datapacket with acceleration data is written also 16 byte of Overhead and 8 byte for the timestamp are written. The figure below shows the memory distribution at the beginning of a sector. As the timestamp is considered useful data it is included in the acceleration data and not part of the overhead. A sector is therefore used as described visible below: Acceleration Data: 89,06% Overhead: 10,74% Unused Space: 0,20% Finally for evaluating the memory usage of the FlashDB, a similar analysis as in the introduction is carried out. Here it is analyzed, how long acceleration data can be logged. The first bar is the external flash, then, 49,03 h are possible without using the FlashDB and 5,4 h are lost when using the FlashDB. 7.4.1 Amount of data wich can be stored The maximum amount of acceleration data which can be stored inside the available flash memory can be computed using the following formula. \\[T_{storable} = \\frac{32}{f_S} * blockcount*{\\rm floor}\\left(\\frac{blocksize-56}{16+8+resolution*\\frac{3*32}{8}}\\right)\\] The formula used the following parameters: Parameter Description \\(f_S\\) Samplingrate in Hz. \\(blockcount\\) Number of blocks available. When using the internal flash this equals to 12. When using Macronix flash the number is 4094. \\(blocksize\\) Size of one block. The number is 4000 if using the internal flash. When using Macronix flash the number is 4096. \\(resolution\\) Resolution of one value in bits. \\(T_{storable}\\) Maximum time of samples which can be stored in the flash memory. 7.4.2 Energy consumption The Macronix flash can operate in two modes: high-performance and low-power. When the Flash is formatted, the high-performance mode is activated to speed up the process. After that, in regular operation mode, it is set back to low-power mode. In the following the energy consumption is analyzed. 7.4.2.1 Low-Power Mode First, the energy consumption is analyzed for flash in low-power mode. Before initializing the flash, an average of 129,6 μA is consumed. The peaks are Bluetooth advertisements. When initializing the falsh, the power consumption goes up: And settles at an average power consumption of 4.5 mA: The process of initializing takes about 2 min and 58 s. While logging the energy consumption is about 20 μA higher than before. 7.4.2.2 High-Performance Mode In high-performance mode, before initializing the flash, an average of 135,26 μA is consumed. That is 6 μA more than in low power mode. When initializing the falsh, the power consumption goes up as seen before: The average power consumption reached is 0,43 mA higher than in low power mode: But on the other hand, the process of initializing takes about 1 min and 42 s that is 1 min and 16 s less than in low power mode. To evaluate the energy consumption and time difference during flash initialization, the electric power for each mode is calculated: Supply voltage: \\(V_{cc} = 3V\\) Initialization time: \\(t_{init\\_lp}=178 s\\) , \\(t_{init\\_hp}=102 s\\) Current: \\(I_{avg\\_hp}=4,48 mA\\) , \\(I_{avg\\_hp}=4,91 mA\\) Electric power Low-Power: \\(W_{lp}=3 V∙178 s∙4,43 mA=2,37 Ws\\) High-Performance: \\(W_{hp}=3 V∙102 s∙4,91 mA=1,50 Ws\\) To reduce the overall power consumption, in normal operation the low power mode is used. Only during flash initialization, the high-performance mode is selected. 7.4.3 GitHub Issue #11 Write Performance on External Flash In this issue limitations due to the write performance of the flash or due to the SPI bus speed are evaluated. The max. page program time is 10 ms in low power mode. Worst case - 4 write function calls: 1. New sector - sector header required 2. Data header 3. Data passing over a page border 4. rest of the data on the next page That results in a maximum of 40ms write time. The data sent in one SPI message is at least 144 byte, therefore 256 bytes is assumed for further calculations. That results in a transmission time of \\(\\frac{256\\bullet8}{8 MHz} = 0,256 ms\\). This time is needed for each time the write function is called, which results in an overall worst case time of ~\\(41ms\\) Assuming data is logged with a frequency of 500 Hz, the timeperiod between two write actions is \\(32\\bullet\\frac{1}{500 Hz}=64ms\\) which is 1.5 times the time consumed for writing (worst case). A test with 100Hz and 200Hz frequency at 12Bit resolution (about 200000 byte) workes without an issue. "],["gateway.html", "Chapter 8 Gateway 8.1 Sensor Gateway Communication Library 8.2 Advertisement logging 8.3 Data storage format", " Chapter 8 Gateway The gateway has three different tasks: Manipulate the state of one or more sensors via control messages Receive acceleration data from one or more sensors, parse and store them Logging Bluetooth advertisements from sensors For the first two tasks there is the “SensorGatewayBleak” library. All Code is written in python. You need the following libraries to run the “SensorGatewayBleak” library: asyncio nest_asyncio bleak bluez crcmod The “AdvertisementLogging” function need the following libraries: ruuvitag_sensor bluez pygatt 8.1 Sensor Gateway Communication Library This library is used for communication between the gateway and the sensors. It sends messages to the sensor to change their state or to get their data. The library has the following functions. This functions take message objects as argument. This message object must fit the needed message object to be processed. 8.1.1 Activate acceleration logging The “activate_logging_at_sensor()” function activates logging at all sensors in Bluetooth range of the gateway. It takes a send_activate_logging_object as argument. To activate the logging, the gateway sends a control acceleration logging (10.2.6) message to the target sensor via the send_activate_logging_object. The message content is 0x4A 0x4A 0x08 0x01. If Logging is already activated an error message (10.3.1) will be received as a status_object. 8.1.2 Deactivate acceleration logging The “deactivate_logging_at_sensor()” function deactivates logging at all sensors in Bluetooth range. It takes a send_deactivate_logging_object as argument. To deactivate the logging, the gateway sends a control acceleration logging (10.2.6) message to the target sensor via the send_deactivate_logging_object. The message content is 0x4A 0x4A 0x08 0x00. Stopping the logging cause a deletion of all flash pages. If Logging is not activated an error message (10.3.1) will be received a status_object. 8.1.3 Set sensor configuration With the “set_config_sensor()” function three sensor properties can be manipulated: Sampling rate (sampling_rate): Measuring interval of the sensor. Allowed values can be found in Chapter (10.2.2). Sampling resolution (sampling_resolution): Resolution of the measured values. Allowed values can be found in Chapter (10.2.2). Measuring range(measuring_range): Measuring range. Allowed values can be found in Chapter (10.2.2). The returned message will be saved in a status message object. Frequenzy divider(divider): The divider is used to get sample frequencies that are not supported by the sampling rate. The configuration will be sent via a “Set configuration of acceleration sensor” (10.2.2) message to all sensors in Bluetooth range. It takes a send_set_config_object as argument. Only arguments with allowed values will be set. All others stay as they are. After setting the configuration all flash pages will be deleted. This can cause a loss of data. The Sensor send a status response message (10.3.1) to the gateway if the configuration was set successful or not. The returned message will be saved as a status_object. 8.1.4 Set sensor time With the “set_sensor_time() “ function all sensors in Bluetooth range will be set to the current time in UTC. It takes a send_set_sensor_time_object as argument. To set the sensor time a “Set system time” (10.2.4) message, with the current time, will be send via send_set_sensor_time_object. After setting the sensor time all flash pages will be deleted. This can cause a loss of data. The Sensor send a response message (@ref(ble-gatt-messages.html#status-response)) to the gateway if the time was set successful or not. The returned message will be saved in a status_object. 8.1.5 Get sensor configuration The “get_config_from_sensor()”send a “Read configuration of acceleration sensor” (10.2.3) message to the target sensor via a send_get_config_object. The sensor returns with a “Configuration response” (10.3.3) message which is storred in config_object. 8.1.6 Get sensor time The “get_time_from_sensor()” function returns the current time from all sensors in Bluetooth range as a time_object. It takes a send_get_senor_time_object as argument. The function sends a “Read system time” (10.2.5) message to all targets and receives “Timestamp response” (10.3.4) messages which is stored in a time_object. 8.1.7 Get acceleration data The “get_acceleration_data()” collect all samples from the defined mac adresses in the send_get_acceleration_data_object in Bluethooth range. It returns a advertisement_data_object. To do this, the gateway sends a “Start transmitting logged data” (?? Message to all targets and receives the data which are followed by an “End of data message” (10.3.2). The returned Message will be saved in an acceloration_data_object. 8.1.8 Get flash statistics With the “get_flash_statistic()” function you can access important information from the internal flash memory of the sensor (10.2.8). It takes a send_get_flash_statistics_object as argument.The returned message will be saved in a flash_statistics_object. 8.1.9 Get logging status The “get_logging_status()” function is used to identify if a sensor is currently logging or if logging is deactivated. It returns a status_object. It takes a send_get_logging_status_object as argument. 1 = logging is active 0 = logging is not active 8.2 Advertisement logging This executable is used for logging all advertisements that are send from any sensor in the Bluetooth rang. It parses the messages the gateway receives in a human readable design and stores it in a Csv file. The “decode_data()” function from the ruuvitag_sensor library is used to parse the received messages from the sensors. 8.3 Data storage format For an easy access, the received advertisement data is stored in csv files. Acceleration data can be saved in csv as well or store the acceleration data message object. We recommend the following structure to save the files: 8.3.1 Csv file acceleration Logging Five values will be stored in these Csv files. These values are: • Acceleration in X directory • Acceleration in Y directory • Acceleration in Z directory • Timestamp • Mac address The name of the Csv file will be “acceleration” plus the observation time. 8.3.2 Csv file advertisement Logging Fourteen values will be stored in these Csv files. These values are: • Data format • Humidity • Temperature in °C • Pressure in Pa • Acceleration • Acceleration in X directory • Acceleration in Y directory • Acceleration in Z directory • Tx power in dBm • Battery in mV • Movement counter • Measurement sequence • Mac address • Timestamp The name of the Csv file is the date of the observation. One Csv file will only include observations from one day. "],["backend.html", "Chapter 9 Backend", " Chapter 9 Backend Lorem ipsum "],["ble-gatt-messages.html", "Chapter 10 BLE GATT Messages 10.1 General message structure 10.2 Control messages 10.3 Response messages 10.4 Data message 10.5 Communication example 10.6 Streaming", " Chapter 10 BLE GATT Messages Communication between Gateway and Sensor is done via Bluetooth Low Energy. It uses the Nordic UART service which itself uses the Bluetooth GATT protocol. At the time of writing this document the Sensor supports two generations of messages. The first generation was defined in Wintersemester 2020/21. These messages are using header bytes starting at 0xFA. Messages which use are reserved by Ruuvi for proprietary messages. Messages from the second generation use header bytes which are defined in the file ruuvi_endpoints.h. 10.1 General message structure The general structure of a message is show in the following table. Header Header Operation Parameter destination source XX Zero or more Parameter The first byte destination addresses the service which should process the message. The second byte source contains the source which originated the message. 10.2 Control messages Control messages are sent to the sensor. They must be padded by nullbytes to a minimum length of 11 bytes. This requirement is introduced by the Ruuvi firmware. The padding bytes are not shown in the following description of the messages. 10.2.1 Start transmitting acceleration data This message starts transmitting of acceleration data. It takes one parameter. It’s concrete content is: 0x4A 0x4A 0x11 P1. The parameter P1 controls the source of the data which should be returned. Parameter Description 0x01 Logged acceleration data from the database should be returned. Data is transmitted by using data messages. The transmission of the data is followed by a end of data message which signals the end of the data. If acceleration logging is not active, the Sensor responds a status response containing error code RD_ERROR_INVALID_STATE. 10.2.2 Set configuration of acceleration sensor This message is used to set the configuration of the acceleration sensor (LIS2DH12). The message takes 8 Parameters. The Sensor responds to this message with a status response. The parameters are as follows. Parameter Description P1 Rate of sampling in smaples per second. Allowed values are 1Hz, 10Hz, 25Hz, 50Hz, 100Hz, 200Hz, 400Hz (use 0xC9). P2 Resolution in bits. Allowed values are 8, 10, 12. P3 Measuring range. Allowed values are 2G, 4G, 8G, 16G. P4 DSP function. See datasheet of LIS2DH12. P5 DSP parameter. See datasheet of LIS2DH12. P6 Mode of operation. Allowed values are 0xF2, 0xF3, 0xF4. See ruuvi_driver_sensor.h for explanation. P7 Frequency divider. This value is used to only save every P7-th value. P8 Reserved. Set to 0x00. All values from P1 to P7 can be set to 0xFF which means ‘do not change this values’. The concrete content of this message is 0x4A 0x4A 0x02 P1 P2 P3 P4 P5 P6 P7 P8. 10.2.3 Read configuration of acceleration sensor This message is used to read the configuration of the acceleration sensor (LIS2DH12). The message takes no parameters. The Sensor responds to this message by a response message which transmits the configuration. The concrete content of this message is: 0x4A 0x4A 0x03. 10.2.4 Set system time This message is used to set the RTC of the sensor to a timestamp which is part of the message. The time is expressed in milliseconds. It must be transmitted in little-endian byte sequence. The sensor responds to this message with a status response. The concrete content of this message is 0x21 0x21 0x08 XX XX XX XX XX XX XX XX. 10.2.5 Read system time This message is used to read the RTC of the sensor. The sensor responds to this message with a timestamp response. The concrete content of this message is 0x21 0x21 0x09. 10.2.6 Control acceleration logging This message is used to activate or deactivate acceleration logging. It takes one parameter. The sensor responds to this message using a status response. Activating acceleration logging when it is already active results in an error. Deactivating acceleration logging when it is not active results in an error. The concrete content of this message is 0x4A 0x4A 0x08 P1. Where P1 can be a value from the following table. Parameter Description 0x00 Disable logging. 0x01 Logging of acceleration data to flash. 0x02 Logging of acceleration data to RAM. Used for logging of high frequency sampling. 10.2.7 Query status of acceleration logging This message is used to query the status of acceleration logging. The sensor responds to this message with a status response. If logging is active, the response contains the status RD_SUCCESS if logging is not active the status is RD_ERROR_NOT_INITIALIZED. Streaming is not interpreted as active logging. In that case, this calls returns RD_ERROR_NOT_INITIALIZED. The concrete content of this message is 0x4A 0x4A 0x09. 10.2.8 Query flash statistic Flash usage is an important information. It is especially useful for determining when it is needed to download logged acceleration data from the sensor. This message is used to query some statistics about the usage of the internal flash memory of the Nordic NRF52832 MCU. It is implemented as an proprietary message. The sensor responds to this message with a flash statistic response. The concrete content of this message is 0xFA 0xFA 0x0D. 10.2.9 Query boot counter This message is used to query the boot counter. It is implemented as an proprietary message. The sensor responds to this message with a boot counter response. The concrete content of this message is 0xFA 0xFA 0x0E. 10.3 Response messages Every response message returns a status code as the result of the processing as the third byte. The following table shows the error conditions. Value Error 0 RD_SUCCESS: No error 1 RD_ERROR_INTERNAL: Internal Error 2 RD_ERROR_NO_MEM: No Memory for operation 4 RD_ERROR_NOT_FOUND: Not found 4 RD_ERROR_NOT_SUPPORTED: Not supported 5 RD_ERROR_INVALID_PARAM: Invalid Parameter 6 RD_ERROR_INVALID_status: Invalid status, operation disallowed in this status 7 RD_ERROR_INVALID_LENGTH: Invalid Length 8 RD_ERROR_INVALID_FLAGS: Invalid Flags 9 RD_ERROR_INVALID_DATA: Invalid Data 10 RD_ERROR_DATA_SIZE: Invalid Data size 11 RD_ERROR_TIMEOUT: Operation timed out 12 RD_ERROR_NULL: Null Pointer 13 RD_ERROR_FORBIDDEN: Forbidden Operation 14 RD_ERROR_INVALID_ADDR: Bad Memory Address 15 RD_ERROR_BUSY: Flash Busy 16 RD_ERROR_RESOURCES: Not enough resources for operation 17 RD_ERROR_NOT_IMPLEMENTED: Not implemented yet 18 RD_ERROR_SELFTEST: Self-test fail 19 RD_STATUS_MORE_AVAILABLE: Driver has more data queued 20 RD_ERROR_NOT_INITIALIZED: Driver is not initialized. 21 RD_ERROR_NOT_ACKNOWLEDGED: Ack was expected but not received 22 RD_ERROR_NOT_ENABLED: Driver is not enabled 10.3.1 Status response This message is used to return a status code to the gateway if no other information is available. Header Header Operation Status destination source operation SS Where SS is the status code. See above table. The header bytes destination and source are the same bytes from the control message but in reversed order. The third byte operation is equal to the byte operation from the control message which caused this response. 10.3.2 End of data message This message is sent to the gateway after returning data. It signals the end of the transmission. This message contains nine parameters. The current configuration of the acceleration sensor are the first eight parameter. The structure is the same as shown in the set configuration message. The CRC16 value of the transmitted data is the 9th parameter. To compute the CRC16 value the polynom 0x11021 with the initial value 0xFFFF is used. The output bytes are not reversed and not XOR’d. The CRC value is of size 2 bytes. It is transfered in little-endian byte sequence. The concrete content of this message is 0x4A 0x4A 0x11 SS P1 P2 P3 P4 P5 P6 P7 P8 CRC1 CRC2. Where SS is the status code. See above table. 10.3.3 Configuration response This message is sent to the gateway after requesting the current configuration. The message contains eight parameters containing the current configuration. If the status code signals an error the transmitted values is undefined. The concrete content of this message is 0x4A 0x4A 0x03 SS P1 P2 P3 P4 P5 P6 P7 P8. The values P1 to P8 map to the same values as shown in set configuration message. Where SS is the status code. See above table. 10.3.4 Timestamp response This message is sent to the gateway after requesting the system time. The message contains one parameter. The parameter is a 8 byte value containing the current timestamp. The bytes are transferred in little-endian sequence. If the status code signals an error the transmitted value is undefined. The concrete content of this message is 0x21 0x21 0x09 SS XX XX XX XX XX XX XX XX. Where SS is the status code. 10.3.5 Flash statistic response The sensor responds to the control message for querying the flash statistic using the following response. Most values were retrived using fds_stat() from Nordic Softdevice. The message contains 11 parameters. Byte Value Description 1 0xFB Header 2 0x0D Header 3 SS Status byte regarding this operation. 4 LS Status regarding the background logging operation. 5 start Unused 0xFF. 6 end Unused 0xFF. 8 size Unused 0xFF. 9-10 valid records The number of valid records. 10-11 dirty records The number of deleted (“dirty”) records. 12-13 words reserved The number of words reserved. 14-15 words used The number of words written to flash, including those reserved for future writes. 16-17 largest continious The largest number of free contiguous words in the file system. 18-19 freeable words The largest number of words that can be reclaimed by garbage collection. Multi byte values are transmitted in little-endian byte sequence. 10.3.6 boot counter response This message is sent to the gateway after requesting the boot counter. The message contains one parameter. The parameter is a 4 byte value containing the value. The bytes are transferred in little-endian sequence. If the status code signals an error the transmitted value is undefined. The concrete content of this message is 0xFB 0x0E SS XX XX XX XX. Where SS is the status code. 10.4 Data message Data messages are used to transfer logged acceleration data. A data message starts with the byte 0x11. After the start byte there follows up to 19 bytes of data. The concrete content of this message is 0x11 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX. The data is returned in blocks of 32 tuples of x-, y-, z-values. Every block is preceded by the timestamp when the interrupt occured which this block generates. To decode the data block the information about the resolution and the scale is needed. This information is transmitted by the end of data message. All values are transferred in little-endian byte sequence. After de-compacting every value must be interpreted as the most significant part of an 16 bit wide signed integer. To get the real acceleration value from this intermediate value multiply it by one of the following factors. Scale / Resolution 8 bit 10 bit 12 bit 2G \\(\\frac{16}{256*1000}\\) \\(\\frac{4}{64*1000}\\) \\(\\frac{1}{16*1000}\\) 4G \\(\\frac{32}{256*1000}\\) \\(\\frac{8}{64*1000}\\) \\(\\frac{2}{16*1000}\\) 8G \\(\\frac{64}{256*1000}\\) \\(\\frac{16}{64*1000}\\) \\(\\frac{4}{16*1000}\\) 16G \\(\\frac{192}{256*1000}\\) \\(\\frac{48}{64*1000}\\) \\(\\frac{12}{16*1000}\\) 10.4.1 12 bit data format In 12 bit resolution mode two values are transmitted inside 3 bytes. See following figure. 10.4.2 10 bit data format In 10 bit resolution mode four values are transmitted inside 5 bytes. See following figure. 10.4.3 8 bit data format In 8 bit resolution mode every value is transmitted seperatly. See following figure. 10.5 Communication example The following figure shows an example communication. 10.6 Streaming Streaming of acceleration data can be activated to retrieve acceleration data at high sampling frequencies. To enable this operation mode logging must be currently disabled. Streaming can not be persistent enabled. It remains active until deactivation using Control acceleration logging command or until power cycle. If streaming is active but no one is connected to BLE GATT service energy consumption is not significant higher than operating the acceleration sensor at this sampling frequency without logging the data. Transfer of sampled data is automatically startet if someone is connected to BLE GATT service. In this case, the data is immediately send to the gateway using the following structure. The concrete content of a message is the following. 0x11 TT TT TT TT TT TT TT TT XX XX XX XX XX XX XX XX XX Each message contains two parameters: Parameter Description TT TT TT TT TT TT TT TT Timestamp of sampling the following value. XX XX XX XX XX XX XX XX XX Acceleration values. Each message transports two tuples of X-, Y-, Z-Acceleration values in compacted format. I.e. without unused bits. Multi byte values are transmitted in little-endian byte sequence. This is relevant for timestamp and acceleration values. To decode the acceleration values one must know the current configuration of the sensor. This information is not part of this message. So, one must save this information from the setup of streaming. "],["messageobjects.html", "Chapter 11 MessageObjects 11.1 return_values_from_sensor 11.2 send_msg_object", " Chapter 11 MessageObjects The message classes should help to communicate with the backend via mqtt. For this task we need to decode the message into json and decode it back to a class later. Additionally, it makes the gateway library more dynamic. There are two types: return_values_from_sensor send_msg_object 11.1 return_values_from_sensor This class takes the returning messages from the sensors and converts them in one of the following objects: time_object config_object flash_statistics_object status_object acceloration_data_object advertisement_data_object Depending on the called constructor this objects can be called via return_values_from_sensor.returnValue. Objects: &gt; time_object: consist of a status, the received time from the sensor and the sensor mac. &gt; config_object: consist of a status, the config parameters from the sensor and the sensor mac. &gt; flash_statistics_object: consist of a status, the flash statistic parameters from the sensor and the sensor mac. &gt; status_object: consist of a status. &gt; acceloration_data_object: consists of the received acceleration data and the sensor mac. &gt; advertisement_data_object: consists of the current time, the advertisement data from the sensor and the mac address form the sensor 11.2 send_msg_object To communicate with the sensor, you must send the right message object. These message object must be one of the following: send_set_sensor_time_object send_set_config_object send_activate_logging_object send_deactivate_logging_object send_get_config_object send_get_senor_time_object send_get_flash_statistics_object send_get_logging_status_object send_get_acceleration_data_object send_activate_advertisement_logging_object All these objects take the targeted mac and a command string. The targeted mac can be a single mac address, multiple macs addresses as list or an empty string. In the last case the command is send to all tags in range. The only purpose of this class is to differentiate between the different commands which are sent to the sensors. To initialize this object the specific constructor in send_msg_objects must be called. "],["sensor-1.html", "Chapter 12 Sensor 12.1 Hardware 12.2 Software", " Chapter 12 Sensor 12.1 Hardware 12.1.1 External Flash Memory For more extensive data logging external memory (not in the SoC) is required. The most promising candidate is the Macronix MX25R as it supports low power battery driven applications, is quite flexible in terms of required voltage and is also used in some newer Nordic reference designs. 12.1.2 Board Redesign The current sensor board revision features two antennas, while the bluetooth antenna is required and onboard NFC antenna is not used, therefore the board footprint could be smaller. Inspiration for a board revision could be drawn from the discontinued nRF51822 Bluetooth Smart Beacon Kit reference design. 12.2 Software 12.2.1 General ToDo Remotely customizing the Heartbeat interval (persistence required) Flexibilizing the Logging Rate so that it can be precisely controlled and the sensor supports rates that the accelerometer does not support natively (e.g. 2 Hz) Adapted Advertisement Message Format: Indicate amount of used internal storage to be used by the gateway to trigger connections and manage dowloading of logged data. 12.2.2 Security Questions: * Can Advertisements be encrypted? * How to manage access for downloading internally stored data and allow for encrypted transportation? "],["gateway-1.html", "Chapter 13 Gateway 13.1 Hardware 13.2 Software", " Chapter 13 Gateway 13.1 Hardware 13.1.1 Uninterruptible Power Supply For operating in remote environments the gateway should be equipped with a Uninterruptible Power Supply (UPS). This allows tolerating short power outages and should be configurable to user alternative energy sources such as solar panel or wind turbines to allow for autonomous operation. The most promising products are: * PiJuice Hat * Sixfab UPS Power Hat * UPS PIco HV4.0B Advanced Questions: * How to work with unregulated power sources such as cheap/raw solar panels? * Which UPS provides the best software (Free/Open/Functionality/Reliability)? 13.1.2 Camera A camera is required to record a video stream that is used to derive the ground truth for classification tasks. Use cases can be extended to perform analytics based on the captured images or the video stream. 13.1.2.1 RPi Camera The main camera for the gateway will be the original camera module offered by the Raspberry Pi Foundation, which provides the benefit of an actively maintained software interface and guaranteed compatibility with the used Single Board Computer (SBC). Additionally it is available in two versions, a normal and a NoIR (Night Vision) Version. Questions: * How to match the video feed with the data that is received via Bluetooth? * Which illumination is required for the NoIR Version? * Is it possible to mechanically align the angles (perfect Video overlay) and use both camera versions simultaneously? 13.1.2.2 Thermal Camera For some use cases it may be reasonable to monitor temperatures via a thermal camera. The thermal camera should be seen as an optional addition to the gateway. Questions: * Which module should be chosen in terms of features (especially resolution and connection) and size? * How to align images from all installed cameras (perfectly aligned video stream)? 13.1.3 3g/4g/5g Module Autonomous operation requires a network connection for control and (at least partial) data transfer. Questions: * Which module can be used solely via the GPIO Header (no USB Cable)? * Which module offers the best software interaface( Free/Open/Functionality/Reliability)? 13.1.4 Bluetooth Hardware Alternating and/or extending the Bluetooth Hardware serves two purposes. Having multiple bluetooth devices should allow for monitoring more sensors simultaneously. Including at least one device with support for external antennas would also allow for increased range. Achieving this goal could can be done using at least one (but potentially both) of the following measures: Adding external Bluetooth Hardware Changing the Single Board Computer (SBC) 13.1.5 Case Heat Sink / Active Ventilation 13.2 Software Scheduling and parallelizing download of logged Data "],["backend-1.html", "Chapter 14 Backend", " Chapter 14 Backend Lorem ipsum "],["contributors.html", "Contributors WS 2020 / 2021 SS 2021 WS 2021 / 2022", " Contributors List of Contributors WS 2020 / 2021 AS FH VB TH WS-20-21-TH.pdf Projectdocumentation SS 2021 DS FH FT JKr JKu LW TH SS-21-TH.pdf Herford-Motor-SS-21-TH.pdf Projectdocumentation Personal application of Ruuvi Sensor WS 2021 / 2022 "],["commerical-applications.html", "Commerical Applications Literature", " Commerical Applications Examples: Smart Pet Tag: https://shop.gethuan.com/ https://www.nordicsemi.com/News/2020/05/Huan-Tag-pet-wearable-helps-owners-keep-track-of-pets-via-crowd-location-system https://www.nordicsemi.com/News/2019/12/The-PitPat-tracker-monitors-pet-exercise-data-with-Nordic-s-nRF52810 https://digitanimal.com/ayuda/ https://www.beaconzone.co.uk/blog/monitoring-cows-and-sheep-using-beacons/ https://anicare.fi/test/#story https://www.nordicsemi.com/News/2019/04/Cellular-IoT-ear-tag-Healtag-tracks-health-and-location-of-herding-animals https://www.arm.com/why-arm/innovation/arm-designs/herddogg https://herddogg.com/product/tracetag-starter-kit/ https://www.irnas.eu/opencollar-pangolin-tracker/ https://reelyactive.github.io/forward-sensor-data-to-initial-state.html https://shop.reelyactive.com/collections/all/products/showcase-kit https://www.rigado.com/presto-kit/ https://www.rigado.com/cascade-iot-gateway/ https://www.rigado.com/integrated-sensors-and-devices/ https://www.beaconzone.co.uk/blog/understanding-sensor-beacon-accelerometer-data/ https://www.hidglobal.de/products/rfid-tags/identification-technologies/ble-beacons-gateways https://www.mokosmart.com/de/beacon-gateway/ https://www.shopnfc.com/de/71-ble-rtls https://mongoose-os.com/kiwi/ https://www.ingics.com/ble_wifi_gw.html https://docs.openmqttgateway.com/use/ble.html#setting-the-number-of-scans-between-before-connect-attempt Gateways: https://www.beaconzone.co.uk/Gateways Solar asset tracker: https://www.nordicsemi.com/News/2020/11/SODAQ-cellular-IoT-asset-tracker https://www.microtronics.com/de/produkte/ATEX-GSM-Bluetooth-Gateway.html Mainflux: https://ieeexplore.ieee.org/document/8476881 https://www.iotone.com/files/pdf/vendor/MFX-1%20Gateway%20Mainflux.pdf file:///Users/benjamin/Downloads/futureinternet-10-00105-v2.pdf Literature https://www.edgexfoundry.org/get-started/ https://github.com/Klika-Tech/nordic-aws-iot-demo#connect-device https://industrie-wegweiser.de/bluetooth-low-energy-iiot-projektbeispiel/ https://subscription.packtpub.com/book/hardware_and_creative/9781786461087/7/ch07lvl1sec35/implementing-a-bluetooth-gateway-on-the-raspberry-pi https://www.amazon.de/Hands-Industrial-Internet-Things-infrastructure/dp/1789537223/ref=pd_rhf_se_s_sspa_dk_rhf_search_pt_sub_0_7/262-4436963-1836263?_encoding=UTF8&amp;pd_rd_i=1789537223&amp;pd_rd_r=b2eab45b-279b-4b71-99ab-13bd8409b631&amp;pd_rd_w=1wQPj&amp;pd_rd_wg=er1Jl&amp;pf_rd_p=94ba13e0-bc65-4c11-8b62-a4039a72ac24&amp;pf_rd_r=EXNB4ANYJZHV09QBQB7A&amp;psc=1&amp;refRID=EXNB4ANYJZHV09QBQB7A&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyS002SFhCQUVHOFJPJmVuY3J5cHRlZElkPUEwNDExNzY1RkJFNkVVSFEwTEIxJmVuY3J5cHRlZEFkSWQ9QTAyNzQ0MTMzTVkzSUtDRjBQQUNEJndpZGdldE5hbWU9c3BfcmhmX3NlYXJjaF9wZXJzb25hbGl6ZWQmYWN0aW9uPWNsaWNrUmVkaXJlY3QmZG9Ob3RMb2dDbGljaz10cnVl "],["system-info.html", "System Info", " System Info Sys.time() ## [1] &quot;2022-01-19 16:39:46 UTC&quot; sessionInfo() ## R version 4.1.2 (2021-11-01) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] kableExtra_1.3.4 knitr_1.37 ## ## loaded via a namespace (and not attached): ## [1] tidyselect_1.1.1 xfun_0.29 purrr_0.3.4 colorspace_2.0-2 ## [5] vctrs_0.3.8 generics_0.1.1 htmltools_0.5.2 viridisLite_0.4.0 ## [9] yaml_2.2.1 utf8_1.2.2 rlang_0.4.12 jquerylib_0.1.4 ## [13] pillar_1.6.4 glue_1.6.0 DBI_1.1.2 lifecycle_1.0.1 ## [17] stringr_1.4.0 munsell_0.5.0 gtable_0.3.0 rvest_1.0.2 ## [21] zip_2.2.0 evaluate_0.14 labeling_0.4.2 fastmap_1.1.0 ## [25] fansi_1.0.2 highr_0.9 Rcpp_1.0.8 scales_1.1.1 ## [29] webshot_0.5.2 farver_2.1.0 systemfonts_1.0.3 ggplot2_3.3.5 ## [33] digest_0.6.29 stringi_1.7.6 openxlsx_4.2.5 bookdown_0.24 ## [37] dplyr_1.0.7 grid_4.1.2 tools_4.1.2 magrittr_2.0.1 ## [41] tibble_3.1.6 crayon_1.4.2 pkgconfig_2.0.3 ellipsis_0.3.2 ## [45] xml2_1.3.3 assertthat_0.2.1 rmarkdown_2.11 svglite_2.0.0 ## [49] httr_1.4.2 rstudioapi_0.13 R6_2.5.1 compiler_4.1.2 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
